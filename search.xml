<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python常见问题汇总</title>
      <link href="/2021/06/20/python-common-problem-summary/"/>
      <url>/2021/06/20/python-common-problem-summary/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Python计算科恩d值"><a href="#1-Python计算科恩d值" class="headerlink" title="1.Python计算科恩d值"></a>1.Python计算科恩d值</h4><pre class="line-numbers language-Python"><code class="language-Python">from numpy import std, mean, sqrt#correct if the population S.D. is expected to be equal for the two groups.def cohen_d(x,y):    nx = len(x)    ny = len(y)    dof = nx + ny - 2    return (mean(x) - mean(y)) / sqrt(((nx-1)*std(x, ddof=1) ** 2 + (ny-1)*std(y, ddof=1) ** 2) / dof)#dummy datax = [2,4,7,3,7,35,8,9]y = [i*2 for i in x]# extra element so that two group sizes are not equal.x.append(10)#correct only if nx=nyd = (mean(x) - mean(y)) / sqrt((std(x, ddof=1) ** 2 + std(y, ddof=1) ** 2) / 2.0)print ("d by the 1st method = " + str(d))if (len(x) != len(y)):    print("The first method is incorrect because nx is not equal to ny.")#correct for more general case including nx !=nyprint ("d by the more general 2nd method = " + str(cohen_d(x,y)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-Python中的self有啥作用？"><a href="#2-Python中的self有啥作用？" class="headerlink" title="2.Python中的self有啥作用？"></a>2.Python中的self有啥作用？</h4><blockquote><p>一直感觉对面向对象不是很了解，前几天突然被问到，self有啥作用的时候，我确实一愣。最开始学的时候感觉理解了，但是没有记录也不知道当时理解了现在忘了，还是根本没理解，anyway，查阅了一些资料，自己也动手了下代码，深入理解下self的作用吧。</p></blockquote><p>一、self是必须的吗？<br>self只有在类的初始化（构造函数）时才会用到，一般我们写函数很少用到：</p><pre class="line-numbers language-Python"><code class="language-Python">def eat():    print('I want to eat')eat()#输出结果是I want to eat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的eat()函数就是一普通的，，看下面的2个类中self的位置：</p><pre class="line-numbers language-Python"><code class="language-Python">class Person():    def __init__(self,name,age):        self.name = name        self.age = ageming = Person('明春','100')print(ming.name) #明春print(ming.age)  #100class Person():    def __init__(xx,name,age):       xx.name = name       xx.age = ageming = Person('明春','100')print(ming.name) #明春print(ming.age) #100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里可以看出来，self换成xx也是可以的，只不过self是大家长久以来默认的一种写法，所以最好还是保持一直吧，不要那么特立独行</p><p>二、self的作用到底是啥呢？</p><p>self就是实例本身，注意不是类，是类的实例，self接收到类的实例所有参数，让然后绑定，通过 点来访问</p><pre class="line-numbers language-Python"><code class="language-Python">class Person():    def __init__(self,name,age):       self.name = name       self.age = ageming = Person('明春','100')print(ming.name)print(ming.age)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如在本例中，ming 是一个实例，ming的所有参数都传到类里了，self它不仅仅是为了在类内部传递参数导入的数据，还能在 初始化函数中，通过 self.attribute 的方式，规定 self 实例对象的属性，这个属性也是类实例化对象的属性，即 做为类通过初始化函数初始化后所具有的属性</p><p>那为啥不能是类本身，看下面的例子：</p><pre class="line-numbers language-Python"><code class="language-Python">class Person():    def __init__(self,name,age):       self.name = name       self.age = ageming = Person('明春','100')chun = Person('春明','001')print(ming.name) #明春print(chun.name) #春明</strong><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果self指向的是Person这个类，那么ming和chun这两个怎么办，self分辨不出来到底传入哪个了。</p><blockquote><p>汇总：self的作用就是指向实例，传入实例所有的数据</p></blockquote><h3 id="3-Python中浮点数计算问题"><a href="#3-Python中浮点数计算问题" class="headerlink" title="3.Python中浮点数计算问题"></a>3.Python中浮点数计算问题</h3><pre class="line-numbers language-Python"><code class="language-Python">a = 1.7b = 0.9 + 0.8if a == b:    print("a 等于 b")else:    print("哎呀，a 不等于 b")# 哎呀，a 不等于 b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Python"><code class="language-Python">a = 1.0b = 0.5 + 0.5if a == b:    print("a 等于 b")else:    print("哎呀，a 不等于 b")#a 等于 b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Python"><code class="language-Python">from decimal import Decimala = Decimal('1.7')b = Decimal('0.9') + Decimal('0.8')if a == b:    print("a 等于 b")else:    print("哎呀，a 不等于 b")#a 等于 b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-matplotlib-plt-出图会闪退"><a href="#4-matplotlib-plt-出图会闪退" class="headerlink" title="4.matplotlib, plt 出图会闪退"></a>4.matplotlib, plt 出图会闪退</h3><p>解决方式：在最后可以加上 plt.pause(0) 可以防止图闪退</p><h3 id="5-Python中list方法的时间比较：append、列表推导式、extend"><a href="#5-Python中list方法的时间比较：append、列表推导式、extend" class="headerlink" title="5.Python中list方法的时间比较：append、列表推导式、extend"></a>5.Python中list方法的时间比较：append、列表推导式、extend</h3><blockquote><p>在Python的数据结构中，list可以说是常用的数据结构，针对list的一些操作，我们来比较下他们的运行时间，以后我们在写相关的代码时，为了有较好的执行效率，可以选择开销小的方法：</p></blockquote><p>一、这里，我们使用Python的timeit库，基本使用方法如下：</p><p>class timeit.Timer(stmt=’pass’, setup=’pass’, timer=<timer function>)<br>Timer是测量小段代码执行速度的类。</timer></p><p>stmt参数是要测试的代码语句（statment）；</p><p>setup参数是运行代码时需要的设置；</p><p>timer参数是一个定时器函数，与平台有关。</p><p>timeit.Timer.timeit(number=1000000)<br>Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p><p>二、比较了append、拼接操作、列表推导式、list()、extend五种方式，以下是测试代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from timeit import Timerdef t1():    li = []    for i in range(10000):        li.append(i)def t2():    li = []    for i in range(10000):        li = li + [i]def t3():    li = [i for i in range(10000)]def t4():    li = list(range(10000))def t5():    li = []    for i in range(10000):        li.extend([i])timer1 = Timer("t1()", "from __main__ import t1")print("append:", timer1.timeit(100))timer2 = Timer("t2()", "from __main__ import t2")print("+:", timer2.timeit(100))timer3 = Timer("t3()", "from __main__ import t3")print("[i for i in range]:", timer3.timeit(100))timer4 = Timer("t4()", "from __main__ import t4")print("list(range()):", timer4.timeit(100))timer5 = Timer("t5()", "from __main__ import t5")print("extend:", timer5.timeit(100))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="time-compare.png" alt></p><blockquote><p>从这里我们可以看出，执行效率从好到差的顺序是：列表推导式 &gt; list() &gt;append &gt; extend&gt;拼接操作,所以，我们要学会使用列表推导式，活学活用。</p></blockquote><h3 id="6-Mac系统下Matplotlib中文显示问题解决"><a href="#6-Mac系统下Matplotlib中文显示问题解决" class="headerlink" title="6.Mac系统下Matplotlib中文显示问题解决"></a>6.Mac系统下Matplotlib中文显示问题解决</h3><p>用Matplotlib显示中文字体一直是个大问题，通过自我探索终于找到解决之道了。</p><p>一、首先我们需要知道系统已经安装了哪些字体，可以通过以下代码展示：</p><pre class="line-numbers language-Python"><code class="language-Python">import matplotlib# 显示mac系统下所有的字体font_list = sorted([f.name for f in matplotlib.font_manager.fontManager.ttflist])for font in font_list:    print(font)输出结果是：Microsoft Sans SerifMicrosoft YaHeiMinion ProMinion ProMinion ProMinion ProMinion Pro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、 找到常用的或者想要的字体，然后通过代码调用：</p><pre class="line-numbers language-Python"><code class="language-Python"># 设置中文字体plt.rcParams['font.family'] = ['FZXiaoBiaoSong-B05S']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>三、生成随机数据，最后可视化展示：</p><pre class="line-numbers language-Python"><code class="language-Python"># 设置随机数据data = np.random.random(100)print(data)plt.title('测试中文显示，我就是个标题')plt.plot(data, '*', label='随机数据分布')plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、最终代码如下：</p><pre class="line-numbers language-Python"><code class="language-Python">import matplotlibimport matplotlib.pyplot as pltimport numpy as np# 显示mac系统下所有的字体font_list = sorted([f.name for f in matplotlib.font_manager.fontManager.ttflist])for font in font_list:    print(font)# 设置随机数据data = np.random.random(100)print(data)# 设置中文字体plt.rcParams['font.family'] = ['FZXiaoBiaoSong-B05S']plt.title('测试中文显示，我就是个标题')plt.plot(data, '*', label='随机数据分布')plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果图：<br><img src="Maptlotlib-zh-cn.png" alt></p><h3 id="7-Python爬取中国研究生招生信息网专业信息"><a href="#7-Python爬取中国研究生招生信息网专业信息" class="headerlink" title="7.Python爬取中国研究生招生信息网专业信息"></a>7.Python爬取中国研究生招生信息网专业信息</h3><blockquote><p>最近想看看研招网有哪些专业，于是用Python写了几行代码，很简单，以下是代码部分：</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> jsonurl <span class="token operator">=</span> <span class="token string">'https://yz.chsi.com.cn/zsml/code/zy.do'</span>header<span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36'</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">1352</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">:</span>            data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'q'</span><span class="token punctuation">:</span><span class="token string">'0'</span><span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>            r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span>params<span class="token operator">=</span>data<span class="token punctuation">,</span>headers<span class="token operator">=</span>header<span class="token punctuation">)</span>            json_srting <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>json_srting<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'q'</span><span class="token punctuation">:</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>            r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> params<span class="token operator">=</span>data<span class="token punctuation">,</span> headers<span class="token operator">=</span>header<span class="token punctuation">)</span>            json_srting <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>json_srting<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是爬取下来的专业信息：<br><img src="major.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面试180题</title>
      <link href="/2021/06/20/python-interview-questison/"/>
      <url>/2021/06/20/python-interview-questison/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Python这门语言入门容易，但是学精比较苦难。入门容易就没有门槛，什么人学能学会，怎么能体现出竞争优势来呢？首先是掌握基础的概念和知识点，然后开始从深度和广度拓展，深度优先，广度次之。以下是来源为CSDN的面试题目，建议逐一解决。</p></blockquote><h3 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h3><pre><code>1.列出 5 个常用 Python 标准库？2.Python 内建数据类型有哪些？3.简述 with 方法打开处理文件帮我我们做了什么？4.列出 Python 中可变数据类型和不可变数据类型，为什么？5.Python 获取当前日期？6.统计字符串每个单词出现的次数7.用 python 删除文件和用 linux 命令删除文件方法8.写一段自定义异常代码9.举例说明异常模块中 try except else finally 的相关意义10.遇到 bug 如何处理</code></pre><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><pre><code>1.谈谈对 Python 和其他语言的区别2.简述解释型和编译型编程语言3.Python 的解释器种类以及相关特点？4.说说你知道的Python3 和 Python2 之间的区别？5.Python3 和 Python2 中 int 和 long 区别？6.xrange 和 range 的区别？</code></pre><h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><pre><code>7.什么是 PEP8?8.了解 Python 之禅么？9.了解 docstring 么？10.了解类型注解么？11.例举你知道 Python 对象的命名规范，例如方法或者类等12.Python 中的注释有几种？13.如何优雅的给一个函数加注释？14.如何给变量加注释？15.Python 代码缩进中是否支持 Tab 键和空格混用。16.是否可以在一句 import 中导入多个库?17.在给 Py 文件命名的时候需要注意什么?18.例举几个规范 Python 代码风格的工具[Python风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/)[PEP8](https://www.python.org/dev/peps/pep-0008/)</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code>#### 字符串19.列举 Python 中的基本数据类型？20.如何区别可变数据类型和不可变数据类型21.将”hello world”转换为首字母大写”Hello World”22.如何检测字符串中只含有数字?23.将字符串”ilovechina”进行反转24.Python 中的字符串格式化方式你知道哪些？25.有一个字符串开头和末尾都有空格，比如“ adabdw ”,要求写一个函数把这个字符串的前后空格都去掉。26.获取字符串”123456“最后的两个字符。27.一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？28. (1)s=”info：xiaoZhang 33 shandong”，用正则切分字符串输出[‘info’, ‘xiaoZhang’, ’33’, ‘shandong’](2) a = “你好 中国 “，去除多余空格只留一个空格。29. (1)怎样将字符串转换为小写 (2)单引号、双引号、三引号的区别？#### 列表30.已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。31.如何实现 “1,2,3” 变成 [“1″,”2″,”3”]32.给定两个 list，A 和 B，找出相同元素和不同元素33.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]34.合并列表[1,5,7,9]和[2,2,6,8]35.如何打乱一个列表的元素？#### 字典36.字典操作中 del 和 pop 有什么区别37.按照字典的内的年龄排序38.请合并下面两个字典 a = {“A”:1,”B”:2},b = {“C”:3,”D”:4}39.如何使用生成式的方式生成一个字典，写一段功能代码。40.如何把元组(“a”,”b”)和元组(1,2)，变为字典{“a”:1,”b”:2}#### 综合41.Python 常用的数据结构的类型及其特性？42.如何交换字典 {“A”：1,”B”：2}的键和值？43.Python 里面如何实现 tuple 和 list 的转换？44.我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？45.请将[i for i in range(3)]改成生成器46.a=”hello”和 b=”你好”编码成 bytes 类型47.下面的代码输出结果是什么？48.下面的代码输出的结果是什么?</code></pre><h3 id="操作类题目"><a href="#操作类题目" class="headerlink" title="操作类题目"></a>操作类题目</h3><pre><code>49.Python 交换两个变量的值50.在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用51.json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？52.json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？53.有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。54.如果当前的日期为 20190530，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20190601)。55.写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。56.下面代码会存在什么问题，如何改进？57.一行代码输出 1-100 之间的所有偶数。58.with 语句的作用，写一段代码？59.python 字典和 json 字符串相互转化方法60.请写一个 Python 逻辑，计算一个文件中的大写字母数量61. 请写一段 Python连接 Mongo 数据库，然后的查询代码。62.说一说 Redis 的基本类型。63. 请写一段 Python连接 Redis 数据库的代码。64. 请写一段 Python 连接 MySQL 数据库的代码。65.了解 Redis 的事务么？66.了解数据库的三范式么？67.了解分布式锁么？68.用 Python 实现一个 Reids 的分布式锁的功能。69.写一段 Python 使用 Mongo 数据库创建索引的代码。</code></pre><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><pre><code>70.函数装饰器有什么作用？请列举说明？71.Python 垃圾回收机制？72.魔法函数 __call__怎么使用?73.如何判断一个对象是函数还是方法？74.@classmethod 和@staticmethod 用法和区别75.Python 中的接口如何实现？76.Python 中的反射了解么?77.metaclass 作用？以及应用场景？78.hasattr() getattr() setattr()的用法79.请列举你知道的 Python 的魔法方法及用途。80.如何知道一个 Python 对象的类型？81.Python 的传参是传值还是传址？82.Python 中的元类(metaclass)使用举例83.简述 any()和 all()方法84.filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]85.什么是猴子补丁？86.在 Python 中是如何管理内存的？87.当退出 Python 时是否释放所有内存分配？</code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><pre><code>88.使用正则表达式匹配出&lt;html&gt;&lt;h1&gt;百度一下，你就知道&lt;/html&gt;中的地址 a=”张明 98 分”，用 re.sub，将 98 替换为 10089.正则表达式匹配中(.*)和(.*?)匹配区别？90.写一段匹配邮箱的正则表达式</code></pre><h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><pre><code>91.解释一下 python 中 pass 语句的作用？92.简述你对 input()函数的理解93.python 中的 is 和==94.Python 中的作用域95.三元运算写法和应用场景？96.了解 enumerate 么？97.列举 5 个 Python 中的标准模块98.如何在函数中设置一个全局变量99.pathlib 的用法举例100.Python 中的异常处理，写一个简单的应用场景101.Python 中递归的最大次数，那如何突破呢？102.什么是面向对象的 mro103.isinstance 作用以及应用场景？104.什么是断言？应用场景？105.lambda 表达式格式以及应用场景？106.新式类和旧式类的区别107.dir()是干什么用的？108.一个包里有三个模块，demo1.py, demo2.py, demo3.py，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。109.列举 5 个 Python 中的异常类型以及其含义110.copy 和 deepcopy 的区别是什么？111.代码中经常遇到的*args, **kwargs 含义及用法。112.Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?113.w、a+、wb 文件写入模式的区别114.举例 sort 和 sorted 的区别115.什么是负索引？116.pprint 模块是干什么的？117.解释一下 Python 中的赋值运算符118.解释一下 Python 中的逻辑运算符119.讲讲 Python 中的位运算符120.在 Python 中如何使用多进制数字？121.怎样声明多个变量并赋值？</code></pre><h3 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h3><pre><code>122.已知：(1) 从 AList 和 BSet 中 查找 4，最坏时间复杂度那个大？(2) 从 AList 和 BSet 中 插入 4，最坏时间复杂度那个大？123.用 Python 实现一个二分查找的函数124.python 单例模式的实现方法125.使用 Python 实现一个斐波那契数列126.找出列表中的重复数字127.找出列表中的单个数字128.写一个冒泡排序129.写一个快速排序130.写一个拓扑排序131.python 实现一个二进制计算132.有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。133.单链表反转134.交叉链表求交点135.用队列实现栈136.找出数据流的中位数137.二叉搜索树中第 K 小的元素</code></pre><h3 id="爬虫相关"><a href="#爬虫相关" class="headerlink" title="爬虫相关"></a>爬虫相关</h3><pre><code>138.在 requests 模块中，requests.content 和 requests.text 什么区别139.简要写一下 lxml 模块的使用方法框架140.说一说 scrapy 的工作流程141.scrapy 的去重原理142.scrapy 中间件有几种类，你用过哪些中间件143.你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？144.为什么会用到代理？145.代理失效了怎么处理？146.列出你知道 header 的内容以及信息147.说一说打开浏览器访问 百度一下，你就知道 获取到结果，整个流程。148.爬取速度过快出现了验证码怎么处理149.scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？150.分布式爬虫主要解决什么问题151.写爬虫是用多进程好？还是多线程好？ 为什么？152.解析网页的解析器使用最多的是哪几个153.需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？154.验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）155.使用最多的数据库（mysql，mongodb，redis 等），对他的理解？</code></pre><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><pre><code>156.TCP 和 UDP 的区别？157.简要介绍三次握手和四次挥手158.什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？</code></pre><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><pre><code>159.举例说明 conccurent.future 的中线程池的用法160.说一说多线程，多进程和协程的区别。161.简述 GIL162.进程之间如何通信163.IO 多路复用的作用？164.select、poll、epoll 模型的区别？165.什么是并发和并行？166.一个线程 1 让线程 2 去调用一个函数怎么实现？167.解释什么是异步非阻塞？168.threading.local 的作用？</code></pre><h3 id="Git-面试题"><a href="#Git-面试题" class="headerlink" title="Git 面试题"></a>Git 面试题</h3><pre><code>169.说说你知道的 git 命令170.git 如何查看某次提交修改的内容</code></pre><p>题目链接：(<a href="https://blog.csdn.net/csdngkk/article/details/99116607" target="_blank" rel="noopener">https://blog.csdn.net/csdngkk/article/details/99116607</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学基础问题及答案</title>
      <link href="/2021/06/20/statistics-basic-questions/"/>
      <url>/2021/06/20/statistics-basic-questions/</url>
      
        <content type="html"><![CDATA[<p>统计学是数据科学和任何数据分析的基础。良好的统计学知识可以帮助数据分析师做出正确的商业决策。一方面，描述性统计帮助我们通过数据的集中趋势和方差了解数据及其属性。另一方面，推断性统计帮助我们从给定的数据样本中推断总体的属性。了解描述性和推断性统计学知识对于立志成为数据科学家或分析师至关重要。为了帮助您提高统计学知识，我们进行了这次实践测试。测试涉及描述性和推断性统计。测试题提供了答案和解释，以防你遇到卡壳的问题。</p><blockquote><p>超过450人参加了这次测试，获得的最高分是37分。以下是一些关于分数分布的统计数据：<br>平均得分：20.40<br>得分中位数：23<br>得分众数：25</p></blockquote><br><br><br><br><p>1、哪些统计方法用来度量数据的集中趋势？</p><p>A）平均值和正态分布</p><p>B）平均值，中位数和众数</p><p>C）众数，Alpha和极差</p><p>D）标准差，极差和平均值</p><p>E）中位数，极差和正态分布</p><br><br><br><p>答案：（B）</p><p>平均值，中位数和众数是分析数据集中趋势的三种统计方法。 我们使用这些测量方法来查找数据集的中心值，以及总结整个数据集。</p><p>2、给出5个数字：（5,10,15,5,15），求单项数据与平均值之间的离差的和。</p><p>A）10</p><p>B）25</p><p>C）50</p><p>D）0</p><p>E）以上都没有</p><br><br><br><p>答案：（D）</p><p>单项数据的离差之和始终为0。</p><p>3、每年进行一次考试。 考试的平均分为150分，标准差为20。如果Ravi的Z值为1.50，他的得分是多少？</p><p>A）180</p><p>B）130</p><p>C）30</p><p>D）150</p><p>E）以上都没有</p><br><br><br><p>答案：（A）</p><p>X =μ+Zσ，其中μ是平均值，σ是标准差，X是我们计算的分数。 因此X = 150 + 20 * 1.5 = 180</p><p>4、如果数据集中的单项数值发生变化，则以下集中趋势中的哪个测量值一定会发生变化？</p><p>A）平均值</p><p>B）中位数</p><p>C）众数</p><p>D）上述所有</p><br><br><br><p>答案：（A）<br>如果我们改动数据集中的任何值，数据集的平均值一定会改变。 因为平均值是由数据集中的所有值汇总求得的，所以数据集中的每个值都对平均值起作用。 中位数和众数可能会改变，也可能不会随数据集中的单个值而改变。</p><p>5、下图所示，标尺的垂线上有六个数据点。以下哪一条垂直线代表给定数据点的平均值？其中标尺的比例单位相同。<br><img src="5.png" alt></p><p>A）A<br>B）B<br>C）C<br>D）D</p><br><br><br>答案：（C）<p>从视觉上观察数据点做判断有点困难， 我们可以通过简单的取值来理解平均值。 令A为1，B为2，C为3等。 所示的数据值将变为{1,1,1,4,5,6}，这意味着是18/6 = 3即C.</p><p>6、如果正偏态分布的中位数为50，则下列哪个选项是正确的？</p><p>A）平均值大于50</p><p>B）平均值小于50</p><p>C）众数小于50</p><p>D）众数大于50</p><p>E）A和C</p><p>F）B和D<br><br><br><br><br><br></p><p>答案：（E）</p><p>以下是负偏态分布，正态分布和正偏态分布曲线：正如我们所看到的正偏态分布的曲线，众数 &lt;中位数 &lt;平均值。 所以如果中位数是50，平均值将超过50，众数将小于50。</p><p>7、以下哪一项是下图分布的中位数的可能值？<br><img src="7.png" alt></p><p>A）32<br>B）26<br>C）17<br>D）40<br><br><br><br><br><br><br>答案：（B）<br>中位数是其前后值大约一半的值。 小于25的数值是（36 + 54 + 69 = 159），大于30的值的数量是（55 + 43 + 25 + 22 + 17 = 162）。 所以中位数应该在25到30之间。因此26是中位数的可能值。</p><p>8、计算样本标准差时，下列哪项陈述对于贝塞尔校正（Bessel’s correction）是正确的？</p><ol><li><p>不论对样本数据执行任何操作，都要使用贝塞尔校正。</p></li><li><p>当我们尝试用样本估计总体的标准差时，使用贝塞尔校正。</p></li><li><p>贝塞尔校正减少了标准差的偏差。</p></li></ol><p>A）只有2</p><p>B）只有3</p><p>C）2和3</p><p>D）1和3<br><br><br><br><br><br></p><p>答案：（C）</p><p>与我们不应该总是做贝塞尔校正这个普遍观点相反。 当我们用样本的标准差来估算总体的标准差时，基本上是要做贝塞尔校正的。贝塞尔校正可以修正样本的标准差使其更接近总体的情况。</p><p>9、如果公式中的分母使用（n-1）计算数据集的方差，则下列哪个选项正确？</p><p>A）数据集是一个样本</p><p>B）数据集是一个总体</p><p>C）数据集可以是样本或总体</p><p>D）数据集来自人口普查</p><p>E）以上都不正确<br><br><br><br><br><br></p><p>答案：（A）</p><p>如果公式中的方差分母使用了n-1，则表示该集合是样本。 我们一般用离差的平方和除以n-1计算平均值，来估算总体的偏差。</p><p>当我们使用总体数据时，可以直接将离差的平方和除以n而不是n-1。</p><p>10、[对错判断]标准差可以为负值。</p><p>A）正确</p><p>B）错误<br><br><br><br><br><br></p><p>答案：（B）</p><p>由于标准差是经过平方，累加，然后再开方，因此标准差不可能是负的。</p><p>11、标准差对异常值是否稳健？A）是B）否<br>答案：（B）<br><br><br><br><br><br><br>按照标准差公式，可以发现过高或过低的值会增加标准差，尽管标准差与平均值非常不同。 因此，异常值将影响标准差。</p><p>12、对于下面的正态分布，以下哪个选项成立？</p><p>σ1，σ2和σ3分别表示曲线1，2和3的标准差。<br><img src="12.png" alt></p><p>A）σ1&gt;σ2&gt;σ3<br>B）σ1&lt;σ2&lt;σ3<br>C）σ1=σ2=σ3<br>D）以上皆否</p><br><br><br>答案：（B）<p>从正态分布的定义来看，我们知道所有这3种形状的曲线下的面积为1。 曲线3更平坦，因而更分散（大多数值在40-160之间），因此它的标准差最大。 类似地，曲线1的范围非常窄，并且所有值都在80-120的小范围内。 因此，曲线1的标准差最小。</p><p>13、在98％的置信区间，双尾检验Z的临界值是多少？<br>A）+/- 2.33<br>B）+/- 1.96</p><p>C）+/- 1.64</p><p>D）+/- 2.55<br><br><br><br><br><br></p><p>答案：（A）<br>我们需要查看Z值表来回答这个问题。 对于双尾检验和98％置信区间，我们应该检查Z值之前的面积为0.99，因为平均值的左侧和右侧分别是1％。 因此，我们应该检查区域 &gt; 0.99的Z值。 该值为+/- 2.33。</p><p>14、[对错判断]标准正态分布的曲线是对称的，对称轴为0，曲线下面的面积为1。</p><p>A）正确</p><p>B）错误<br><br><br><br><br><br></p><p>答案：（A）</p><p>由正态分布曲线的定义得知，曲线下面的面积为1，对称轴为零， 平均值、中位数和众数都等于0。平均值左侧的面积等于平均值右侧的面积。 因此它是对称的。</p><p>问题背景15-17</p><p>研究表明，在学习时听音乐可以提高记忆力。 为了证明这一点，研究人员获得了36名大学生的样本，给他们做了一个标准记忆测试，同时听一些背景音乐。 在正常情况下（没有音乐），测试得到的平均分为25，标准偏差为6。实验后样本（有音乐）的平均分为28。</p><p>15、这种情况下的零假设是什么？</p><p>A）学习时听音乐不会影响记忆力。</p><p>B）学习时听音乐可能会使记忆力退化。</p><p>C）在学习中听音乐可能会提高记忆力。</p><p>D）在学习期间听音乐不会提高记忆力，还可能会使记忆力变得更糟。<br><br><br><br><br><br></p><p>答案：（D）</p><p>零假设通常是假设声明，测量现象彼此之间没有关系。 这里的零假设是听音乐和记忆力的提高之间没有关系。</p><p>16）什么是第一类错误？</p><p>A）学习时听音乐可以提高记忆力，且该结论正确。</p><p>B）学习时听音乐可以提高记忆力，但实际上记忆力并没有提高。</p><p>C）学习时听音乐不会提高记忆力，但实际上记忆力提高了。<br><br><br><br><br><br></p><p>答案：（B）</p><p>第一类错误意味着当假设的结论实际上为真时，我们却拒绝了零假设。 这里的零假设是音乐不会提高记忆力。 第一类错误是我们拒绝了零假设，也就是说结论显示音乐提高了记忆力，但实际上它并没有提高记忆力。</p><p>17）执行Z检验后，我们可以得出什么结论？</p><p>A）听音乐不会提高记忆力。</p><p>B）听音乐会显著提高记忆力。</p><p>C）信息不足以作任何结论。</p><p>D）以上都不对<br><br><br><br><br><br></p><p>答案：（B）</p><p>我们在给定的情况下进行Z检验。 我们知道零假设是听音乐不会提高记忆力。</p><p>备择假设是听音乐确实提高了记忆力。</p><p>在这种情况下，标准误差即：</p><p>来自这个总体的样本的平均值为28的Z值得分为：</p><p>从Z值表中可以看出，α= 0.05（单尾）的Z临界值为1.65。因此，由于观察到的Z值大于Z临界值，所以我们可以拒绝零假设，可以下结论说听音乐确实改善了记忆力，置信度是95％。18）研究者从他的分析中得出结论：安慰剂治疗了艾滋病。 他犯了哪一类的错误？A）第一类错误<br>B）第二类错误</p><p>C）以上都不是。 研究人员没有发生错误。</p><p>D）不能确定<br><br><br><br><br><br></p><p>答案：（D）</p><p>根据定义，第一类错误是假设实际是真时，拒绝零假设；第二类错误是假设实际是假时，接受零假设。 在这种情况下定义错误，我们需要首先定义零假设和备择假设。</p><p>19）当我们往数据中引入一些异常值时，置信区间会发生什么变化？</p><p>A）置信区间对异常值是稳健的</p><p>B）置信区间随着异常值的引入而增加。</p><p>C）随着异常值的引入，置信区间将减少。</p><p>D）在这种情况下，我们无法确定置信区间。<br><br><br><br><br><br></p><p>答案：（B）</p><p>我们知道置信区间取决于数据的标准差。 如果我们将异常值引入数据，则标准差增加，因此置信区间也增加。</p><p>问题背景20-22</p><p>医生想通过控制饮食来降低所有患者的血糖水平。 他发现所有患者的血糖含量平均值为180，标准差为18。然后有9名患者开始控制饮食，他观察到样本的平均值为175。现在，他正在考虑建议让他的所有患者都去控制饮食。</p><p>备注：置信区间99％。</p><p>20）平均值的标准误差是多少？</p><p>A）9</p><p>B）6</p><p>C）7.5</p><p>D）18<br><br><br><br><br><br></p><p>答案：（B）</p><p>平均值的标准误差是标准差除以样本量的平方根。即：</p><p>21）当所有患者都开始控制饮食后，血糖平均值降至175以下的概率是多少？<br>A）20%<br>B）25%<br>C）15%<br>D）12%<br><br><br><br><br><br></p><p>答案：（A）</p><p>这个问题需要计算出干预后所有患者的平均血糖值为175的概率， 可以通过给定的平均值计算出Z值。</p><p>查Z值表，得到Z对应的数值 = -0.833〜0.2033。因此，如果每个人都开始控制饮食，那么所有患者平均血糖值降至175的概率大约为20％。22）以下哪项陈述是正确的？<br>A）医生有有效的证据证明控制饮食可以降低血糖水平。<br>B）医生没有足够的证据证明控制饮食能够降低血糖水平。<br>C）如果医生用同样的方法让所有患者控制饮食，那么平均血糖将会降至160以下。<br><br><br><br><br><br><br>答案：（B）</p><p>我们需要核实是否有足够的证据来拒绝零假设。 零假设是控制饮食对血糖没有影响。 这是一个双尾检验。 双尾检验的Z临界值为±2.58。我们计算出的Z值是-0.833。由于Z值 &lt; Z临界值，因此我们没有足够的证据证明控制饮食能够降低血糖。</p><p>问题背景23-25</p><p>一位研究人员正在试图检验两种不同教学方法的效果。 他把20名学生分成两组，每组10人。 对于第1组，教学方法是使用有趣的例子。 对于第2组，教学方法是使用软件来帮助学生学习。 两组学生经过20分钟的授课后，所有学生进行了考试。</p><p>我们想计算两组学生的考试得分是否有显著的差异。</p><p>已知如下信息：</p><p>• α= 0.05，双尾检验。</p><p>• 第1组的测试平均分数= 10</p><p>• 第2组的测试平均分数= 7</p><p>• 标准误差= 0.94</p><p>23） t-统计量的值是什么？</p><p>A）3.191</p><p>B） 3.395</p><p>C）不能确定</p><p>D）以上都不是<br><br><br><br><br><br></p><p>答案：（A）</p><p>t统计量是指两组之间相差多少个标准误差。</p><p>=（10-7）/ 0.94 = 3.191</p><p>24）两组的考试得分是否有显著差异？</p><p>A）有</p><p>B）没有<br><br><br><br><br><br></p><p>答案：（A）</p><p>零假设是两组之间没有差异，而被择假设是两组之间有显著差异。</p><p>在α= 0.05条件下的双尾检验的t临界值为±2.101。 得到t统计量为3.191。 由于t统计量大于t临界值，因此我们可以拒绝零假设，认为这两组在95％的置信区间上有显著差异。</p><p>25) 考试得分的变异性在多大比例上可由教学方法不同来解释？</p><p>A) 36.13</p><p>B) 45.21</p><p>C) 40.33</p><p>D) 32.97<br><br><br><br><br><br></p><p>答案：（A）</p><p>R2的值给出了分数变异性的百分比。R2的公式如下：</p><p>在本题中，自由度是10 + 10 -2，因为两组各有10人，所以自由度是18。</p><p>26）[对错判断] F统计量不能为负。<br>A）正确<br>B）错误<br><br><br><br><br><br><br>答案：（A）<br>F统计量是我们对不同组进行方差分析，了解不同组之间的差异时得到的值。 F统计量是组间变异与组内变异的比值。</p><p>下面是F统计量的公式：</p><p>由于分子和分母具有平方项，因此F统计量不能为负。<br>27）下列哪张图具有很强的正相关性？<br><img src="27.png" alt></p><p>答案：（B）强正相关需要满足下列条件：如果x增加，y也增加；如果x减少，y也减小。 在这种情况下，线的斜率为正，数据点将显示出明确的线性关系。 选项B显示出很强的正相关关系。28）两个变量（Var1和Var2）之间的相关性为0.65。 如果给Var1中的所有值加上2后，相关系数将会<strong>___</strong>？A）增加<br>B）减少</p><p>C）以上都没有</p><p>答案：（C）</p><p>任一变量增加或减去一个恒定值，相关系数将保持不变。相关性的计算公式可以很容易地帮助我们理解这一点。</p><p>如果我们给变量的所有值都加上一个常数值，则这个变量将发生相同的变化量，变量的差异将保持不变。 因此，相关系数不会变化。</p><p>29）据观察发现，数学考试成绩与在学生在考试当天进行体育运动存在非常高的相关性。 你能从中推断出什么结论？1. 高度相关意味着运动后考试成绩会很高。</p><ol start="2"><li><p>相关性并不意味着因果关系。</p></li><li><p>相关性衡量了运动量与考试成绩之间的线性关系的强度。</p></li></ol><p>A）只有1</p><p>B）1和3</p><p>C）2和3</p><p>D) 以上陈述都对</p><p>答案：（C）</p><p>虽然有时直觉上强相关性就表明因果关系，但实际上相关性并不意味着任何的因果推论。 它只是告诉我们两个变量之间的关系的强度。 如果这两个变量同时改变，那么它们之间存在高度的相关性。</p><p>30）如果数学考试成绩与体育运动之间的相关系数（r）是0.86，那么用体育运动来解释数学考试成绩的变异性的百分比是多少？</p><p>A）86%</p><p>B）74%</p><p>C）14%</p><p>D）26%</p><p>答案：（B）</p><p>变异性的百分比R2由相关系数的平方得到， 该比值可以解释由一个变量引起另一个变量变异的比例。 因此，用运动解释数学考试成绩的变异性为0.862。</p><p>31）下列选项对于直方图的描述，哪个是正确的？<br><img src="31.png" alt></p><p>A）上述直方图是单峰的<br>B）上述直方图是双峰的<br>C）上述给出的不是直方图<br>D）以上都不对</p><p>答案：（B）</p><p>上述直方图是双峰的。 我们可以看到直方图有两个峰值，表示有两个高频。</p><p>32）考虑回归直线方程y = ax + b，其中a是斜率，b是截距。 如果我们知道斜率的值，那么通过下列哪个选项，我们一定可以找到截距的值？</p><p>A）把值（0, 0）代入到回归直线方程中</p><p>B）代入回归拟合线上任意一点的值，计算b的值</p><p>C）使用方程中的x和y的平均值，和a一起计算得到b</p><p>D）以上都不对</p><p>答案：（C）</p><p>使用普通最小二乘回归法的直线始终通过x和y的平均值。 如果我们知道线上的任意一个点和斜率的值，就可以很容易地找到截距。</p><p>33）当我们向线性回归模型引入更多的变量时会发生什么？</p><p>A）R2可能增加或保持不变，调整后的R2可能增加也可能减少。</p><p>B）R2可能增加也可能减少，但调整后的R2总是增加。</p><p>C）当为模型引入新的变量时，R2和调整后的R2总是增加。</p><p>D）R2和调整后的R2都有可能增加或减少，依赖于引入的变量。</p><p>答案：（A）</p><p>R2总是增加或至少保持不变，因为使用普通最小二乘法，向模型添加更多的变量，方差的总和不会增加，R2也没有减少。调整后的R2是在模型中根据预测变量的数量进行调整后，R2的修改版本。只有当新的预测变量改进了模型且超过预期时，调整后的R2才会增加。当预测变量对模型的改进低于预期时，调整后的R2将减少。</p><p>34）在散点图中，回归线上面或下面的点到回归线的垂直距离称为____？<br><img src="34.png" alt></p><p>A）残差<br>B）预测误差C）预测D）A和B<br>E）以上都不是</p><p>答案：（D）</p><p>我们从图中看到的线是从回归线到点的垂直距离， 这些距离被称为残差或预测误差。</p><p>35）在最小二乘法的一元线性回归方程中，相关系数与决定系数之间的关系是？</p><p>A）两者无关</p><p>B）决定系数是相关系数的平方</p><p>C）决定系数是相关系数的平方根</p><p>D） 两者都是相同的</p><p>答案：（B）</p><p>决定系数是R2，告诉我们自变量解释因变量的变异程度，也是相关系数的平方。 在多元回归的情况下，R2也可表示成解释方差之和与方差总和的比值。</p><p>36）显著性水平与置信度之间的关系是什么？</p><p>A）显著性水平=置信度</p><p>B）显著性水平= 1-置信度</p><p>C）显著性水平= 1 /置信度</p><p>D）显著性水平= sqrt（1 – 置信度）</p><p>答案：（B）</p><p>显著性水平就是1-置信度。 如果显著性水平为0.05，那么相应的置信度为95％或0.95。显著性水平就是当零假设为真时，获得极端值或超过极端值的结果的概率。 置信区间是总体参数可能值的范围，如总体平均值。 例如，如果你在95％的置信区间内计算出冰淇淋的平均价格，那么说明你有95％的信心认为这个平均价格包含了所有冰淇淋的真实平均价格。</p><p>显著性水平和置信度在正态分布中是互补的。</p><p>37）[对错判断] 假设给定一个变量V以及其平均值和中位数。 基于这些值，你可以判断出变量“V”是有偏的。</p><p>平均值（V）&gt;中位数（V）</p><p>A）正确</p><p>B）错误</p><p>答案：（B）</p><p>因为没有提到变量V的分布类型，我们不能肯定地说V是有偏的。</p><p>38）普通最小二乘法（OLS）线性回归方程得到的回归线试图____？</p><p>A）通过尽可能多的点</p><p>B）通过尽可能少的点</p><p>C）最小化所触及的点数</p><p>D）最小化点到回归线的距离的平方</p><p>答案：（D）</p><p>回归线尝试最小化点到回归线之间的距离的平方。根据定义，普通最小二乘法回归方程具有误差的平方的最小和。 这意味着残差的平方和也应该是最小化的。这条回归线可能会也可能不会通过最多的数据点。最常见的情况是，当数据有很多离群值或线性关系不是非常强的时候，回归线不是通过所有的点，而是尽量减少通过的点的误差平方和。</p><p>39）下表是一个线性回归方程（Y = 5X＋40）。<br><img src="39.png" alt></p><p>以下哪一项是该线性方程模型的MAE（平均绝对误差）？<br>A）8.4<br>B）10.29<br>C）42.5<br>D）以上都不是</p><p>答案：（A）</p><p>为了计算本题中的平均绝对误差，我们首先用给定的方程计算Y值，然后计算相对于实际Y值的绝对误差。 那么这个绝对误差的平均值将是平均绝对误差。 下表总结了这些值。</p><p>40）对体重（y）和身高（x）进行回归分析得出以下最小二乘直线：y = 120 + 5x。 这意味着如果身高增加1英寸，则预期的体重将？A）增加1磅B）增加5磅C）增加125磅<br>D）以上都不是</p><p>答案：（B）</p><p>观察给定方程y = 120 + 5x， 如果身高增加1个单位，则体重将增加5磅。因为截距120是不变的，不会贡献差异。</p><p>41）[对错判断] 皮尔森（Pearson）相关性捕捉了两个变量之间的线性依赖关系，而斯皮尔曼（Spearman）相关性捕捉的是两个变量之间的单调相关关系。</p><p>A）正确</p><p>B）错误</p><p>答案：（A）</p><p>该表述正确。皮尔森（Pearson）相关性评估了两个连续变量之间的线性相关关系。 当一个变量的变化与另一个变量的变化成比例时，相关关系是线性的。而斯皮尔曼（Spearman）相关性是评价单调相关关系。 单调相关关系是两个变量共同变化，但是不一定以固定的比例变化。</p>]]></content>
      
      
      <categories>
          
          <category> 统计学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-如何阅读源码</title>
      <link href="/2021/06/20/how-to-read-code/"/>
      <url>/2021/06/20/how-to-read-code/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文来自于技术大佬——左耳耗子，以下是他对于如何阅读源码的建议，我认为对于我的学习很有帮助。</p></blockquote><p><img src="read-code.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网路基础知识之HTTP协议详解</title>
      <link href="/2021/06/20/http-basic/"/>
      <url>/2021/06/20/http-basic/</url>
      
        <content type="html"><![CDATA[<h3 id="请求-客户端-到-服务端-request"><a href="#请求-客户端-到-服务端-request" class="headerlink" title="请求:客户端 到 服务端[request]"></a>请求:客户端 到 服务端[request]</h3><pre><code>GET(请求的方式) /books/java.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)Accept: */*(客户端能接收的资源类型)Accept-Language: en-us(客户端接收的语言类型)Connection: Keep-Alive(维护客户端和服务端的连接关系)Host: localhost:8080(连接的目标主机和端口号)Referer: http://localhost/links.asp(从来于哪里)User-Agent: Mozilla/4.0(客户端版本号的名字)Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)If-Modified-Since: Tue, 11 Jul 2015 18:23:51 GMT(缓存时间)Cookie(客户端暂存服务端的信息)Date: Tue, 11 Jul 2015 18:23:51 GMT(客户端请求服务端的时间)</code></pre><h3 id="响应-服务端-到-客户端-response"><a href="#响应-服务端-到-客户端-response" class="headerlink" title="响应:服务端 到 客户端[response]"></a>响应:服务端 到 客户端[response]</h3><pre><code>HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)302（客户端请求服务端，但服务端没有对应的资源，服务端要客户端再次请求找其它的服务端，即客户端二次请求，重定向）307（客户端请求服务端，但服务端没有对应的资源，服务端自行再次请求找其它的服务端，即客户端一次请求，转发）304（客户端请求服务端，此时客户端缓存中有，无需再从服务端下载新的内容,服务端叫客户端自行找缓存，优化）500(客户端请求的资源，服务端存在，但在执行时出错）Location: http://www.baidu.com(服务端需要客户端访问的页面路径)Server:apache tomcat(服务端的Web服务端名)Content-Encoding: gzip(服务端能够发送压缩编码类型)Content-Length: 80(服务端发送的压缩数据的长度)Content-Language: zh-cn(服务端发送的语言类型)Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)Last-Modified: Tue, 11 Jul 2015 18:23:51 GMT(服务端对该资源最后修改的时间)Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)Transfer-Encoding: chunked(分块传递数据到客户端）Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)Expires: -1//3种(服务端禁止客户端缓存页面数据)Cache-Control: no-cache(服务端禁止客户端缓存页面数据)Pragma: no-cache(服务端禁止客户端缓存页面数据)Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)Date: Tue, 11 Jul 2015 18:23:51 GMT(服务端响应客户端的时间)Accept：浏览器可接受的MIME类型。Accept-Charset：浏览器可接受的字符集。Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。Content-Length：表示请求消息正文的长度。Cookie：这是最重要的请求头信息之一From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。Host：初始URL中的主机和端口。If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。HTTP响应头概述（HttpServletResponse）Web服务器的HTTP应答一般由以下几项构成：一个状态行，一个或多个应答头，一个空行，内容文档。设置HTTP应答头往往和设置状态行中的状态代码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401（Unauthorized）状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。setDateHeader方法和setIntHeadr方法专门用来设置包含日期和整数值的应答头，前者避免了把Java时间转换为GMT时间字符串的麻烦，后者则避免了把整数转换为字符串的麻烦。HttpServletResponse还提供了许多设置setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。addCookie：设置一个Cookie（Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头）。另外，如上节介绍，sendRedirect方法设置状态代码302时也会设置Location头。</code></pre><h3 id="HTTP响应头说明："><a href="#HTTP响应头说明：" class="headerlink" title="HTTP响应头说明："></a>HTTP响应头说明：</h3><pre><code>Allow：服务器支持哪些请求方法（如GET、POST等）。Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。Expires：应该在什么时候认为文档已经过期，从而不再缓存它？Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path”)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的&lt;META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path”&gt;实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV=”Refresh” …&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。Server：服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。WWW-Authenticate ：客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=\”executives\””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive函数语法大全</title>
      <link href="/2021/06/19/hive-systax-summary/"/>
      <url>/2021/06/19/hive-systax-summary/</url>
      
        <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、关系运算："><a href="#一、关系运算：" class="headerlink" title="一、关系运算："></a>一、关系运算：</h4><ol><li>等值比较: =    </li><li>不等值比较: &lt;&gt;    </li><li>小于比较: &lt;    </li><li>小于等于比较: &lt;=    </li><li>大于比较: &gt;    </li><li>大于等于比较: &gt;=    </li><li>空值判断: IS NULL    </li><li>非空判断: IS NOT NULL    </li><li>LIKE比较: LIKE    </li><li>JAVA的LIKE操作: RLIKE    </li><li>REGEXP操作: REGEXP    <h4 id="二、数学运算："><a href="#二、数学运算：" class="headerlink" title="二、数学运算："></a>二、数学运算：</h4></li><li>加法操作: +    </li><li>减法操作: -    </li><li>乘法操作: *    </li><li>除法操作: /    </li><li>取余操作: %    </li><li>位与操作: &amp;    </li><li>位或操作: |    </li><li>位异或操作: ^</li><li>位取反操作: ~    <h4 id="三、逻辑运算："><a href="#三、逻辑运算：" class="headerlink" title="三、逻辑运算："></a>三、逻辑运算：</h4></li><li>逻辑与操作: AND</li><li>逻辑或操作: OR</li><li>逻辑非操作: NOT<h4 id="四、数值计算"><a href="#四、数值计算" class="headerlink" title="四、数值计算"></a>四、数值计算</h4></li><li>取整函数: round    </li><li>指定精度取整函数: round</li><li>向下取整函数: floor    </li><li>向上取整函数: ceil    </li><li>向上取整函数: ceiling    </li><li>取随机数函数: rand    </li><li>自然指数函数: exp    </li><li>以10为底对数函数: log10    </li><li>以2为底对数函数: log2    </li><li>对数函数: log    </li><li>幂运算函数: pow    </li><li>幂运算函数: power    </li><li>开平方函数: sqrt    </li><li>二进制函数: bin    </li><li>十六进制函数: hex    </li><li>反转十六进制函数: unhex    </li><li>进制转换函数: conv    </li><li>绝对值函数: abs    </li><li>正取余函数: pmod    </li><li>正弦函数: sin    </li><li>反正弦函数: asin    </li><li>余弦函数: cos    </li><li>反余弦函数: acos    </li><li>positive函数: positive    </li><li>negative函数: negative    <h4 id="五、日期函数"><a href="#五、日期函数" class="headerlink" title="五、日期函数"></a>五、日期函数</h4></li><li>UNIX时间戳转日期函数: from_unixtime    </li><li>获取当前UNIX时间戳函数: unix_timestamp    </li><li>日期转UNIX时间戳函数: unix_timestamp    </li><li>指定格式日期转UNIX时间戳函数: unix_timestamp    </li><li>日期时间转日期函数: to_date</li><li>日期转年函数: year    </li><li>日期转月函数: month</li><li>日期转天函数: day    </li><li>日期转小时函数: hour</li><li>日期转分钟函数: minute</li><li>日期转秒函数: second    </li><li>日期转周函数: weekofyear    </li><li>日期比较函数: datediff    </li><li>日期增加函数: date_add    </li><li>日期减少函数: date_sub<h4 id="六、条件函数"><a href="#六、条件函数" class="headerlink" title="六、条件函数"></a>六、条件函数</h4></li><li>If函数: if    </li><li>非空查找函数: COALESCE    </li><li>条件判断函数：CASE    </li><li>条件判断函数：CASE    <h4 id="七、字符串函数"><a href="#七、字符串函数" class="headerlink" title="七、字符串函数"></a>七、字符串函数</h4></li><li>字符串长度函数：length    </li><li>字符串反转函数：reverse    </li><li>字符串连接函数：concat    </li><li>带分隔符字符串连接函数：concat_ws</li><li>字符串截取函数：substr,substring    </li><li>字符串截取函数：substr,substring</li><li>字符串转大写函数：upper,ucase    </li><li>字符串转小写函数：lower,lcase    </li><li>去空格函数：trim    </li><li>左边去空格函数：ltrim    </li><li>右边去空格函数：rtrim    </li><li>正则表达式替换函数：regexp_replace</li><li>正则表达式解析函数：regexp_extract</li><li>URL解析函数：parse_url    </li><li>json解析函数：get_json_object</li><li>空格字符串函数：space    </li><li>重复字符串函数：repeat</li><li>首字符ascii函数：ascii    </li><li>左补足函数：lpad    </li><li>右补足函数：rpad    </li><li>分割字符串函数: split    </li><li>集合查找函数: find_in_set    <h4 id="八、集合统计函数"><a href="#八、集合统计函数" class="headerlink" title="八、集合统计函数"></a>八、集合统计函数</h4></li><li>个数统计函数: count    </li><li>总和统计函数: sum    </li><li>平均值统计函数: avg    </li><li>最小值统计函数: min    </li><li>最大值统计函数: max    </li><li>非空集合总体变量函数: var_pop    </li><li>非空集合样本变量函数: var_samp    </li><li>总体标准偏离函数: stddev_pop    </li><li>样本标准偏离函数: stddev_samp    <h4 id="10．中位数函数-percentile"><a href="#10．中位数函数-percentile" class="headerlink" title="10．中位数函数: percentile"></a>10．中位数函数: percentile</h4></li><li>中位数函数: percentile    </li><li>近似中位数函数: percentile_approx    </li><li>近似中位数函数: percentile_approx    </li><li>直方图: histogram_numeric    <h4 id="九、复合类型构建操作"><a href="#九、复合类型构建操作" class="headerlink" title="九、复合类型构建操作"></a>九、复合类型构建操作</h4></li><li>Map类型构建: map    </li><li>Struct类型构建: struct    </li><li>array类型构建: array    <h4 id="十、复杂类型访问操作"><a href="#十、复杂类型访问操作" class="headerlink" title="十、复杂类型访问操作"></a>十、复杂类型访问操作</h4></li><li>array类型访问: A[n]    </li><li>map类型访问: M[key]    </li><li>struct类型访问: S.x    <h4 id="十一、复杂类型长度统计函数"><a href="#十一、复杂类型长度统计函数" class="headerlink" title="十一、复杂类型长度统计函数"></a>十一、复杂类型长度统计函数</h4></li><li>Map类型长度函数: size(Map&lt;K.V&gt;)    </li><li>array类型长度函数: size(Array<t>)    </t></li><li>类型转换函数    </li></ol><br><br><br><br><br><p>一、关系运算：</p><ol><li><p>等值比较: =<br> 语法：A=B<br> 操作类型：所有基本类型<br> 描述: 如果表达式A与表达式B相等，则为TRUE；否则为FALSE</p><pre><code> 举例： hive&gt; select 1 from lxw_dual where 1=1; 1</code></pre></li><li><p>不等值比较: &lt;&gt;<br> 语法: A &lt;&gt; B<br>操作类型: 所有基本类型<br>描述: 如果表达式A为NULL，或者表达式B为NULL，返回NULL；如果表达式A与表达式B不相等，则为TRUE；否则为FALSE</p><pre><code>举例：hive&gt; select 1 from lxw_dual where 1 &lt;&gt; 2;1</code></pre></li><li><p>小于比较: &lt;<br> 语法: A &lt; B<br>操作类型: 所有基本类型<br>描述: 如果表达式A为NULL，或者表达式B为NULL，返回NULL；如果表达式A小于表达式B，则为TRUE；否则为FALSE</p><pre><code>举例：hive&gt; select 1 from lxw_dual where 1 &lt; 2;1</code></pre></li></ol><ol start="4"><li><p>小于等于比较: &lt;=<br>语法: A &lt;= B<br>操作类型: 所有基本类型<br>描述: 如果表达式A为NULL，或者表达式B为NULL，返回NULL；如果表达式A小于或者等于表达式B，则为TRUE；否则为FALSE</p><pre><code>举例：hive&gt; select 1 from lxw_dual where 1 &lt;= 1;1</code></pre></li><li><p>大于比较: &gt;<br>语法: A &gt; B<br>操作类型: 所有基本类型<br>描述: 如果表达式A为NULL，或者表达式B为NULL，返回NULL；如果表达式A大于表达式B，则为TRUE；否则为FALSE<br>举例：<br>hive&gt; select 1 from lxw_dual where 2 &gt; 1;<br>1</p></li><li><p>大于等于比较: &gt;=<br>语法: A &gt;= B<br>操作类型: 所有基本类型<br>描述: 如果表达式A为NULL，或者表达式B为NULL，返回NULL；如果表达式A大于或者等于表达式B，则为TRUE；否则为FALSE<br>举例：<br>hive&gt; select 1 from lxw_dual where 1 &gt;= 1;<br>1</p></li></ol><p>注意：String的比较要注意(常用的时间比较可以先to_date之后再比较)<br>hive&gt; select * from lxw_dual;<br>OK<br>2011111209 00:00:00     2011111209</p><p>hive&gt; select a,b,a&lt;b,a&gt;b,a=b from lxw_dual;<br>2011111209 00:00:00     2011111209      false   true    false</p><ol start="7"><li><p>空值判断: IS NULL<br>语法: A IS NULL<br>操作类型: 所有类型<br>描述: 如果表达式A的值为NULL，则为TRUE；否则为FALSE<br>举例：<br>hive&gt; select 1 from lxw_dual where null is null;<br>1</p></li><li><p>非空判断: IS NOT NULL<br>语法: A IS NOT NULL<br>操作类型: 所有类型<br>描述: 如果表达式A的值为NULL，则为FALSE；否则为TRUE<br>举例：<br>hive&gt; select 1 from lxw_dual where 1 is not null;<br>1</p></li><li><p>LIKE比较: LIKE<br>语法: A LIKE B<br>操作类型: strings<br>描述: 如果字符串A或者字符串B为NULL，则返回NULL；如果字符串A符合表达式B   的正则语法，则为TRUE；否则为FALSE。B中字符”_”表示任意单个字符，而字符”%”表示任意数量的字符。<br>举例：<br>hive&gt; select 1 from lxw_dual where ‘football’ like ‘foot%’;<br>1<br>hive&gt; select 1 from lxw_dual where ‘football’ like ‘foot____’;<br>1<br>注意：否定比较时候用NOT A LIKE B<br>hive&gt; select 1 from lxw_dual where NOT ‘football’ like ‘fff%’;<br>1</p></li><li><p>JAVA的LIKE操作: RLIKE<br>语法: A RLIKE B<br>操作类型: strings<br>描述: 如果字符串A或者字符串B为NULL，则返回NULL；如果字符串A符合JAVA正则表达式B的正则语法，则为TRUE；否则为FALSE。<br>举例：<br>hive&gt; select 1 from lxw_dual where ‘footbar’ rlike ‘^f.*r$’;<br>1<br>注意：判断一个字符串是否全为数字：<br>hive&gt;select 1 from lxw_dual where ‘123456’ rlike ‘^\\d+$’;<br>1<br>hive&gt; select 1 from lxw_dual where ‘123456aa’ rlike ‘^\\d+$’;</p></li><li><p>REGEXP操作: REGEXP<br>语法: A REGEXP B<br>操作类型: strings<br>描述: 功能与RLIKE相同<br>举例：<br>hive&gt; select 1 from lxw_dual where ‘footbar’ REGEXP ‘^f.*r$’;<br>1<br>二、数学运算：</p></li><li><p>加法操作: +<br>语法: A + B<br>操作类型：所有数值类型<br>说明：返回A与B相加的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。比如，int + int 一般结果为int类型，而int + double 一般结果为double类型<br>举例：<br>hive&gt; select 1 + 9 from lxw_dual;<br>10<br>hive&gt; create table lxw_dual as select 1 + 1.2 from lxw_dual;<br>hive&gt; describe lxw_dual;<br>_c0     double</p></li><li><p>减法操作: -<br>语法: A – B<br>操作类型：所有数值类型<br>说明：返回A与B相减的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。比如，int – int 一般结果为int类型，而int – double 一般结果为double类型<br>举例：<br>hive&gt; select 10 – 5 from lxw_dual;<br>5<br>hive&gt; create table lxw_dual as select 5.6 – 4 from lxw_dual;<br>hive&gt; describe lxw_dual;<br>_c0     double</p></li><li><p>乘法操作: <em><br>语法: A </em> B<br>操作类型：所有数值类型<br>说明：返回A与B相乘的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。注意，如果A乘以B的结果超过默认结果类型的数值范围，则需要通过cast将结果转换成范围更大的数值类型<br>举例：<br>hive&gt; select 40 * 5 from lxw_dual;<br>200</p></li><li><p>除法操作: /<br>语法: A / B<br>操作类型：所有数值类型<br>说明：返回A除以B的结果。结果的数值类型为double<br>举例：<br>hive&gt; select 40 / 5 from lxw_dual;</p></li><li><p>0</p></li></ol><p>注意：hive中最高精度的数据类型是double,只精确到小数点后16位，在做除法运算的时候要特别注意<br>hive&gt;select ceil(28.0/6.999999999999999999999) from lxw_dual limit 1;<br>结果为4<br>hive&gt;select ceil(28.0/6.99999999999999) from lxw_dual limit 1;<br>结果为5</p><ol start="5"><li><p>取余操作: %<br>语法: A % B<br>操作类型：所有数值类型<br>说明：返回A除以B的余数。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。<br>举例：<br>hive&gt; select 41 % 5 from lxw_dual;<br>1<br>hive&gt; select 8.4 % 4 from lxw_dual;</p></li><li><p>40000000000000036<br>注意：精度在hive中是个很大的问题，类似这样的操作最好通过round指定精度<br>hive&gt; select round(8.4 % 4 , 2) from lxw_dual;</p></li><li><p>4</p></li><li><p>位与操作: &amp;<br>语法: A &amp; B<br>操作类型：所有数值类型<br>说明：返回A和B按位进行与操作的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。<br>举例：<br>hive&gt; select 4 &amp; 8 from lxw_dual;<br>0<br>hive&gt; select 6 &amp; 4 from lxw_dual;<br>4</p></li><li><p>位或操作: |<br>语法: A | B<br>操作类型：所有数值类型<br>说明：返回A和B按位进行或操作的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。<br>举例：<br>hive&gt; select 4 | 8 from lxw_dual;<br>12<br>hive&gt; select 6 | 8 from lxw_dual;<br>14</p></li><li><p>位异或操作: ^<br>语法: A ^ B<br>操作类型：所有数值类型<br>说明：返回A和B按位进行异或操作的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。<br>举例：<br>hive&gt; select 4 ^ 8 from lxw_dual;<br>12<br>hive&gt; select 6 ^ 4 from lxw_dual;<br>2</p></li></ol><p>9．位取反操作: ~<br>语法: ~A<br>操作类型：所有数值类型<br>说明：返回A按位取反操作的结果。结果的数值类型等于A的类型。<br>举例：<br>hive&gt; select ~6 from lxw_dual;<br>-7<br>hive&gt; select ~4 from lxw_dual;<br>-5<br>三、逻辑运算：</p><ol><li><p>逻辑与操作: AND<br>语法: A AND B<br>操作类型：boolean<br>说明：如果A和B均为TRUE，则为TRUE；否则为FALSE。如果A为NULL或B为NULL，则为NULL<br>举例：<br>hive&gt; select 1 from lxw_dual where 1=1 and 2=2;<br>1</p></li><li><p>逻辑或操作: OR<br>语法: A OR B<br>操作类型：boolean<br>说明：如果A为TRUE，或者B为TRUE，或者A和B均为TRUE，则为TRUE；否则为FALSE<br>举例：<br>hive&gt; select 1 from lxw_dual where 1=2 or 2=2;<br>1</p></li><li><p>逻辑非操作: NOT<br>语法: NOT A<br>操作类型：boolean<br>说明：如果A为FALSE，或者A为NULL，则为TRUE；否则为FALSE<br>举例：<br>hive&gt; select 1 from lxw_dual where not 1=2;<br>1</p></li></ol><p>四、数值计算</p><ol><li><p>取整函数: round<br>语法: round(double a)<br>返回值: BIGINT<br>说明: 返回double类型的整数值部分 （遵循四舍五入）<br>举例：<br>hive&gt; select round(3.1415926) from lxw_dual;<br>3<br>hive&gt; select round(3.5) from lxw_dual;<br>4<br>hive&gt; create table lxw_dual as select round(9542.158) from lxw_dual;<br>hive&gt; describe lxw_dual;<br>_c0     bigint</p></li><li><p>指定精度取整函数: round<br>语法: round(double a, int d)<br>返回值: DOUBLE<br>说明: 返回指定精度d的double类型<br>举例：<br>hive&gt; select round(3.1415926,4) from lxw_dual;</p></li><li><p>1416</p></li><li><p>向下取整函数: floor<br>语法: floor(double a)<br>返回值: BIGINT<br>说明: 返回等于或者小于该double变量的最大的整数<br>举例：<br>hive&gt; select floor(3.1415926) from lxw_dual;<br>3<br>hive&gt; select floor(25) from lxw_dual;<br>25</p></li><li><p>向上取整函数: ceil<br>语法: ceil(double a)<br>返回值: BIGINT<br>说明: 返回等于或者大于该double变量的最小的整数<br>举例：<br>hive&gt; select ceil(3.1415926) from lxw_dual;<br>4<br>hive&gt; select ceil(46) from lxw_dual;<br>46</p></li><li><p>向上取整函数: ceiling<br>语法: ceiling(double a)<br>返回值: BIGINT<br>说明: 与ceil功能相同<br>举例：<br>hive&gt; select ceiling(3.1415926) from lxw_dual;<br>4<br>hive&gt; select ceiling(46) from lxw_dual;<br>46</p></li><li><p>取随机数函数: rand<br>语法: rand(),rand(int seed)<br>返回值: double<br>说明: 返回一个0到1范围内的随机数。如果指定种子seed，则会等到一个稳定的随机数序列<br>举例：<br>hive&gt; select rand() from lxw_dual;</p></li><li><p>5577432776034763<br>hive&gt; select rand() from lxw_dual;</p></li><li><p>6638336467363424<br>hive&gt; select rand(100) from lxw_dual;</p></li><li><p>7220096548596434<br>hive&gt; select rand(100) from lxw_dual;</p></li><li><p>7220096548596434</p></li><li><p>自然指数函数: exp<br>语法: exp(double a)<br>返回值: double<br>说明: 返回自然对数e的a次方<br>举例：<br>hive&gt; select exp(2) from lxw_dual;</p></li><li><p>38905609893065<br>自然对数函数: ln<br>语法: ln(double a)<br>返回值: double<br>说明: 返回a的自然对数<br>举例：<br>hive&gt; select ln(7.38905609893065) from lxw_dual;</p></li><li><p>0</p></li><li><p>以10为底对数函数: log10<br>语法: log10(double a)<br>返回值: double<br>说明: 返回以10为底的a的对数<br>举例：<br>hive&gt; select log10(100) from lxw_dual;</p></li><li><p>0</p></li><li><p>以2为底对数函数: log2<br>语法: log2(double a)<br>返回值: double<br>说明: 返回以2为底的a的对数<br>举例：<br>hive&gt; select log2(8) from lxw_dual;</p></li><li><p>0</p></li><li><p>对数函数: log<br>语法: log(double base, double a)<br>返回值: double<br>说明: 返回以base为底的a的对数<br>举例：<br>hive&gt; select log(4,256) from lxw_dual;</p></li><li><p>0</p></li><li><p>幂运算函数: pow<br>语法: pow(double a, double p)<br>返回值: double<br>说明: 返回a的p次幂<br>举例：<br>hive&gt; select pow(2,4) from lxw_dual;</p></li><li><p>0</p></li><li><p>幂运算函数: power<br>语法: power(double a, double p)<br>返回值: double<br>说明: 返回a的p次幂,与pow功能相同<br>举例：<br>hive&gt; select power(2,4) from lxw_dual;</p></li><li><p>0</p></li><li><p>开平方函数: sqrt<br>语法: sqrt(double a)<br>返回值: double<br>说明: 返回a的平方根<br>举例：<br>hive&gt; select sqrt(16) from lxw_dual;</p></li><li><p>0</p></li><li><p>二进制函数: bin<br>语法: bin(BIGINT a)<br>返回值: string<br>说明: 返回a的二进制代码表示<br>举例：<br>hive&gt; select bin(7) from lxw_dual;<br>111</p></li><li><p>十六进制函数: hex<br>语法: hex(BIGINT a)<br>返回值: string<br>说明: 如果变量是int类型，那么返回a的十六进制表示；如果变量是string类型，则返回该字符串的十六进制表示<br>举例：<br>hive&gt; select hex(17) from lxw_dual;<br>11<br>hive&gt; select hex(‘abc’) from lxw_dual;<br>616263</p></li><li><p>反转十六进制函数: unhex<br>语法: unhex(string a)<br>返回值: string<br>说明: 返回该十六进制字符串所代码的字符串<br>举例：<br>hive&gt; select unhex(‘616263’) from lxw_dual;<br>abc<br>hive&gt; select unhex(‘11’) from lxw_dual;</p></li></ol><p>-<br>hive&gt; select unhex(616263) from lxw_dual;<br>abc</p><ol start="17"><li><p>进制转换函数: conv<br>语法: conv(BIGINT num, int from_base, int to_base)<br>返回值: string<br>说明: 将数值num从from_base进制转化到to_base进制<br>举例：<br>hive&gt; select conv(17,10,16) from lxw_dual;<br>11<br>hive&gt; select conv(17,10,2) from lxw_dual;<br>10001</p></li><li><p>绝对值函数: abs<br>语法: abs(double a)   abs(int a)<br>返回值: double        int<br>说明: 返回数值a的绝对值<br>举例：<br>hive&gt; select abs(-3.9) from lxw_dual;</p></li><li><p>9<br>hive&gt; select abs(10.9) from lxw_dual;</p></li><li><p>9</p></li><li><p>正取余函数: pmod<br>语法: pmod(int a, int b),pmod(double a, double b)<br>返回值: int double<br>说明: 返回正的a除以b的余数<br>举例：<br>hive&gt; select pmod(9,4) from lxw_dual;<br>1<br>hive&gt; select pmod(-9,4) from lxw_dual;<br>3</p></li><li><p>正弦函数: sin<br>语法: sin(double a)<br>返回值: double<br>说明: 返回a的正弦值<br>举例：<br>hive&gt; select sin(0.8) from lxw_dual;</p></li><li><p>7173560908995228</p></li><li><p>反正弦函数: asin<br>语法: asin(double a)<br>返回值: double<br>说明: 返回a的反正弦值<br>举例：<br>hive&gt; select asin(0.7173560908995228) from lxw_dual;</p></li><li><p>8</p></li><li><p>余弦函数: cos<br>语法: cos(double a)<br>返回值: double<br>说明: 返回a的余弦值<br>举例：<br>hive&gt; select cos(0.9) from lxw_dual;</p></li><li><p>6216099682706644</p></li><li><p>反余弦函数: acos<br>语法: acos(double a)<br>返回值: double<br>说明: 返回a的反余弦值<br>举例：<br>hive&gt; select acos(0.6216099682706644) from lxw_dual;</p></li><li><p>9</p></li><li><p>positive函数: positive<br>语法: positive(int a), positive(double a)<br>返回值: int double<br>说明: 返回a<br>举例：<br>hive&gt; select positive(-10) from lxw_dual;</p></li></ol><p>-10<br>hive&gt; select positive(12) from lxw_dual;<br>12</p><ol start="25"><li>negative函数: negative<br>语法: negative(int a), negative(double a)<br>返回值: int double<br>说明: 返回-a<br>举例：<br>hive&gt; select negative(-5) from lxw_dual;<br>5<br>hive&gt; select negative(8) from lxw_dual;</li></ol><p>-8<br>五、日期函数</p><ol><li><p>UNIX时间戳转日期函数: from_unixtime<br>语法: from_unixtime(bigint unixtime[, string format])<br>返回值: string<br>说明: 转化UNIX时间戳（从1970-01-01 00:00:00 UTC到指定时间的秒数）到当前时区的时间格式<br>举例：<br>hive&gt; select from_unixtime(1323308943,’yyyyMMdd’) from lxw_dual;<br>20111208</p></li><li><p>获取当前UNIX时间戳函数: unix_timestamp<br>语法: unix_timestamp()<br>返回值: bigint<br>说明: 获得当前时区的UNIX时间戳<br>举例：<br>hive&gt; select unix_timestamp() from lxw_dual;<br>1323309615</p></li><li><p>日期转UNIX时间戳函数: unix_timestamp<br>语法: unix_timestamp(string date)<br>返回值: bigint<br>说明: 转换格式为”yyyy-MM-dd HH:mm:ss”的日期到UNIX时间戳。如果转化失败，则返回0。<br>举例：<br>hive&gt; select unix_timestamp(‘2011-12-07 13:01:03’) from lxw_dual;<br>1323234063</p></li><li><p>指定格式日期转UNIX时间戳函数: unix_timestamp<br>语法: unix_timestamp(string date, string pattern)<br>返回值: bigint<br>说明: 转换pattern格式的日期到UNIX时间戳。如果转化失败，则返回0。<br>举例：<br>hive&gt; select unix_timestamp(‘20111207 13:01:03’,’yyyyMMdd HH:mm:ss’) from lxw_dual;<br>1323234063</p></li><li><p>日期时间转日期函数: to_date<br>语法: to_date(string timestamp)<br>返回值: string<br>说明: 返回日期时间字段中的日期部分。<br>举例：<br>hive&gt; select to_date(‘2011-12-08 10:03:01’) from lxw_dual;<br>2011-12-08</p></li><li><p>日期转年函数: year<br>语法: year(string date)<br>返回值: int<br>说明: 返回日期中的年。<br>举例：<br>hive&gt; select year(‘2011-12-08 10:03:01’) from lxw_dual;<br>2011<br>hive&gt; select year(‘2012-12-08’) from lxw_dual;<br>2012</p></li><li><p>日期转月函数: month<br>语法: month (string date)<br>返回值: int<br>说明: 返回日期中的月份。<br>举例：<br>hive&gt; select month(‘2011-12-08 10:03:01’) from lxw_dual;<br>12<br>hive&gt; select month(‘2011-08-08’) from lxw_dual;<br>8</p></li><li><p>日期转天函数: day<br>语法: day (string date)<br>返回值: int<br>说明: 返回日期中的天。<br>举例：<br>hive&gt; select day(‘2011-12-08 10:03:01’) from lxw_dual;<br>8<br>hive&gt; select day(‘2011-12-24’) from lxw_dual;<br>24</p></li><li><p>日期转小时函数: hour<br>语法: hour (string date)<br>返回值: int<br>说明: 返回日期中的小时。<br>举例：<br>hive&gt; select hour(‘2011-12-08 10:03:01’) from lxw_dual;<br>10</p></li><li><p>日期转分钟函数: minute<br>语法: minute (string date)<br>返回值: int<br>说明: 返回日期中的分钟。<br>举例：<br>hive&gt; select minute(‘2011-12-08 10:03:01’) from lxw_dual;<br>3</p></li><li><p>日期转秒函数: second<br>语法: second (string date)<br>返回值: int<br>说明: 返回日期中的秒。<br>举例：<br>hive&gt; select second(‘2011-12-08 10:03:01’) from lxw_dual;<br>1</p></li><li><p>日期转周函数: weekofyear<br>语法: weekofyear (string date)<br>返回值: int<br>说明: 返回日期在当前的周数。<br>举例：<br>hive&gt; select weekofyear(‘2011-12-08 10:03:01’) from lxw_dual;<br>49</p></li><li><p>日期比较函数: datediff<br>语法: datediff(string enddate, string startdate)<br>返回值: int<br>说明: 返回结束日期减去开始日期的天数。<br>举例：<br>hive&gt; select datediff(‘2012-12-08’,’2012-05-09’) from lxw_dual;<br>213</p></li><li><p>日期增加函数: date_add<br>语法: date_add(string startdate, int days)<br>返回值: string<br>说明: 返回开始日期startdate增加days天后的日期。<br>举例：<br>hive&gt; select date_add(‘2012-12-08’,10) from lxw_dual;<br>2012-12-18</p></li><li><p>日期减少函数: date_sub<br>语法: date_sub (string startdate, int days)<br>返回值: string<br>说明: 返回开始日期startdate减少days天后的日期。<br>举例：<br>hive&gt; select date_sub(‘2012-12-08’,10) from lxw_dual;<br>2012-11-28</p></li></ol><p>六、条件函数</p><ol><li><p>If函数: if<br>语法: if(boolean testCondition, T valueTrue, T valueFalseOrNull)<br>返回值: T<br>说明:  当条件testCondition为TRUE时，返回valueTrue；否则返回valueFalseOrNull<br>举例：<br>hive&gt; select if(1=2,100,200) from lxw_dual;<br>200<br>hive&gt; select if(1=1,100,200) from lxw_dual;<br>100</p></li><li><p>非空查找函数: COALESCE<br>语法: COALESCE(T v1, T v2, …)<br>返回值: T<br>说明:  返回参数中的第一个非空值；如果所有值都为NULL，那么返回NULL<br>举例：<br>hive&gt; select COALESCE(null,’100’,’50′) from lxw_dual;<br>100</p></li><li><p>条件判断函数：CASE<br>语法: CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END<br>返回值: T<br>说明：如果a等于b，那么返回c；如果a等于d，那么返回e；否则返回f<br>举例：<br>hive&gt; Select case 100 when 50 then ‘tom’ when 100 then ‘mary’ else ‘tim’ end from lxw_dual;<br>mary<br>hive&gt; Select case 200 when 50 then ‘tom’ when 100 then ‘mary’ else ‘tim’ end from lxw_dual;<br>tim</p></li><li><p>条件判断函数：CASE<br>语法: CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END<br>返回值: T<br>说明：如果a为TRUE,则返回b；如果c为TRUE，则返回d；否则返回e<br>举例：<br>hive&gt; select case when 1=2 then ‘tom’ when 2=2 then ‘mary’ else ‘tim’ end from lxw_dual;<br>mary<br>hive&gt; select case when 1=1 then ‘tom’ when 2=2 then ‘mary’ else ‘tim’ end from lxw_dual;<br>tom</p></li></ol><p>七、字符串函数</p><ol><li><p>字符串长度函数：length<br>语法: length(string A)<br>返回值: int<br>说明：返回字符串A的长度<br>举例：<br>hive&gt; select length(‘abcedfg’) from lxw_dual;<br>7</p></li><li><p>字符串反转函数：reverse<br>语法: reverse(string A)<br>返回值: string<br>说明：返回字符串A的反转结果<br>举例：<br>hive&gt; select reverse(abcedfg’) from lxw_dual;<br>gfdecba</p></li><li><p>字符串连接函数：concat<br>语法: concat(string A, string B…)<br>返回值: string<br>说明：返回输入字符串连接后的结果，支持任意个输入字符串<br>举例：<br>hive&gt; select concat(‘abc’,’def’,’gh’) from lxw_dual;<br>abcdefgh</p></li><li><p>带分隔符字符串连接函数：concat_ws<br>语法: concat_ws(string SEP, string A, string B…)<br>返回值: string<br>说明：返回输入字符串连接后的结果，SEP表示各个字符串间的分隔符<br>举例：<br>hive&gt; select concat_ws(‘,’,’abc’,’def’,’gh’) from lxw_dual;<br>abc,def,gh</p></li><li><p>字符串截取函数：substr,substring<br>语法: substr(string A, int start),substring(string A, int start)<br>返回值: string<br>说明：返回字符串A从start位置到结尾的字符串<br>举例：<br>hive&gt; select substr(‘abcde’,3) from lxw_dual;<br>cde<br>hive&gt; select substring(‘abcde’,3) from lxw_dual;<br>cde<br>hive&gt;  select substr(‘abcde’,-1) from lxw_dual;  （和ORACLE相同）<br>e</p></li><li><p>字符串截取函数：substr,substring<br>语法: substr(string A, int start, int len),substring(string A, int start, int len)<br>返回值: string<br>说明：返回字符串A从start位置开始，长度为len的字符串<br>举例：<br>hive&gt; select substr(‘abcde’,3,2) from lxw_dual;<br>cd<br>hive&gt; select substring(‘abcde’,3,2) from lxw_dual;<br>cd<br>hive&gt;select substring(‘abcde’,-2,2) from lxw_dual;<br>de</p></li><li><p>字符串转大写函数：upper,ucase<br>语法: upper(string A) ucase(string A)<br>返回值: string<br>说明：返回字符串A的大写格式<br>举例：<br>hive&gt; select upper(‘abSEd’) from lxw_dual;<br>ABSED<br>hive&gt; select ucase(‘abSEd’) from lxw_dual;<br>ABSED</p></li><li><p>字符串转小写函数：lower,lcase<br>语法: lower(string A) lcase(string A)<br>返回值: string<br>说明：返回字符串A的小写格式<br>举例：<br>hive&gt; select lower(‘abSEd’) from lxw_dual;<br>absed<br>hive&gt; select lcase(‘abSEd’) from lxw_dual;<br>absed</p></li><li><p>去空格函数：trim<br>语法: trim(string A)<br>返回值: string<br>说明：去除字符串两边的空格<br>举例：<br>hive&gt; select trim(‘ abc ‘) from lxw_dual;<br>abc</p></li><li><p>左边去空格函数：ltrim<br>语法: ltrim(string A)<br>返回值: string<br>说明：去除字符串左边的空格<br>举例：<br>hive&gt; select ltrim(‘ abc ‘) from lxw_dual;<br>abc</p></li><li><p>右边去空格函数：rtrim<br>语法: rtrim(string A)<br>返回值: string<br>说明：去除字符串右边的空格<br>举例：<br>hive&gt; select rtrim(‘ abc ‘) from lxw_dual;<br>abc</p></li><li><p>正则表达式替换函数：regexp_replace<br>语法: regexp_replace(string A, string B, string C)<br>返回值: string<br>说明：将字符串A中的符合java正则表达式B的部分替换为C。注意，在有些情况下要使用转义字符,类似oracle中的regexp_replace函数。<br>举例：<br>hive&gt; select regexp_replace(‘foobar’, ‘oo|ar’, ‘’) from lxw_dual;<br>fb</p></li><li><p>正则表达式解析函数：regexp_extract<br>语法: regexp_extract(string subject, string pattern, int index)<br>返回值: string<br>说明：将字符串subject按照pattern正则表达式的规则拆分，返回index指定的字符。<br>举例：<br>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.<em>?)(bar)’, 1) from lxw_dual;<br>the<br>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.</em>?)(bar)’, 2) from lxw_dual;<br>bar<br>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.<em>?)(bar)’, 0) from lxw_dual;<br>foothebar<br>注意，在有些情况下要使用转义字符，下面的等号要用双竖线转义，这是java正则表达式的规则。<br>select data_field,<br>regexp_extract(data_field,’.</em>?bgStart\\=([^&amp;]+)’,1) as aaa,<br>regexp_extract(data_field,’.<em>?contentLoaded_headStart\\=([^&amp;]+)’,1) as bbb,<br>regexp_extract(data_field,’.</em>?AppLoad2Req\\=([^&amp;]+)’,1) as ccc<br>from pt_nginx_loginlog_st<br>where pt = ‘2012-03-26’ limit 2;</p></li><li><p>URL解析函数：parse_url<br>语法: parse_url(string urlString, string partToExtract [, string keyToExtract])<br>返回值: string<br>说明：返回URL中指定的部分。partToExtract的有效值为：HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.<br>举例：<br>hive&gt; select parse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;" target="_blank" rel="noopener">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;</a>, ‘HOST’) from lxw_dual;<br>facebook.com<br>hive&gt; select parse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;" target="_blank" rel="noopener">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1&#39;</a>, ‘QUERY’, ‘k1’) from lxw_dual;<br>v1</p></li><li><p>json解析函数：get_json_object<br>语法: get_json_object(string json_string, string path)<br>返回值: string<br>说明：解析json的字符串json_string,返回path指定的内容。如果输入的json字符串无效，那么返回NULL。<br>举例：<br>hive&gt; select  get_json_object(‘{“store”:</p><blockquote><p>  {“fruit”:[{“weight”:8,”type”:”apple”},{“weight”:9,”type”:”pear”}],<br>   “bicycle”:{“price”:19.95,”color”:”red”}<br>  },<br> “email”:”<a href="mailto:amy@only_for_json_udf_test.net" target="_blank" rel="noopener">amy@only_for_json_udf_test.net</a>“,<br> “owner”:”amy”<br>}<br>‘,’$.owner’) from lxw_dual;<br>amy</p></blockquote></li><li><p>空格字符串函数：space<br>语法: space(int n)<br>返回值: string<br>说明：返回长度为n的字符串<br>举例：<br>hive&gt; select space(10) from lxw_dual;<br>hive&gt; select length(space(10)) from lxw_dual;<br>10</p></li><li><p>重复字符串函数：repeat<br>语法: repeat(string str, int n)<br>返回值: string<br>说明：返回重复n次后的str字符串<br>举例：<br>hive&gt; select repeat(‘abc’,5) from lxw_dual;<br>abcabcabcabcabc</p></li><li><p>首字符ascii函数：ascii<br>语法: ascii(string str)<br>返回值: int<br>说明：返回字符串str第一个字符的ascii码<br>举例：<br>hive&gt; select ascii(‘abcde’) from lxw_dual;<br>97</p></li><li><p>左补足函数：lpad<br>语法: lpad(string str, int len, string pad)<br>返回值: string<br>说明：将str进行用pad进行左补足到len位<br>举例：<br>hive&gt; select lpad(‘abc’,10,’td’) from lxw_dual;<br>tdtdtdtabc<br>注意：与GP，ORACLE不同，pad 不能默认</p></li><li><p>右补足函数：rpad<br>语法: rpad(string str, int len, string pad)<br>返回值: string<br>说明：将str进行用pad进行右补足到len位<br>举例：<br>hive&gt; select rpad(‘abc’,10,’td’) from lxw_dual;<br>abctdtdtdt</p></li><li><p>分割字符串函数: split<br>语法:  split(string str, string pat)<br>返回值:  array<br>说明: 按照pat字符串分割str，会返回分割后的字符串数组<br>举例：<br>hive&gt; select split(‘abtcdtef’,’t’) from lxw_dual;<br>[“ab”,”cd”,”ef”]</p></li><li><p>集合查找函数: find_in_set<br>语法: find_in_set(string str, string strList)<br>返回值: int<br>说明: 返回str在strlist第一次出现的位置，strlist是用逗号分割的字符串。如果没有找该str字符，则返回0<br>举例：<br>hive&gt; select find_in_set(‘ab’,’ef,ab,de’) from lxw_dual;<br>2<br>hive&gt; select find_in_set(‘at’,’ef,ab,de’) from lxw_dual;<br>0</p></li></ol><p>八、集合统计函数</p><ol><li><p>个数统计函数: count<br>语法: count(<em>), count(expr), count(DISTINCT expr[, expr_.])<br>返回值: int<br>说明: count(</em>)统计检索出的行的个数，包括NULL值的行；count(expr)返回指定字段的非空值的个数；count(DISTINCT expr[, expr_.])返回指定字段的不同的非空值的个数<br>举例：<br>hive&gt; select count(*) from lxw_dual;<br>20<br>hive&gt; select count(distinct t) from lxw_dual;<br>10</p></li><li><p>总和统计函数: sum<br>语法: sum(col), sum(DISTINCT col)<br>返回值: double<br>说明: sum(col)统计结果集中col的相加的结果；sum(DISTINCT col)统计结果中col不同值相加的结果<br>举例：<br>hive&gt; select sum(t) from lxw_dual;<br>100<br>hive&gt; select sum(distinct t) from lxw_dual;<br>70</p></li><li><p>平均值统计函数: avg<br>语法: avg(col), avg(DISTINCT col)<br>返回值: double<br>说明: avg(col)统计结果集中col的平均值；avg(DISTINCT col)统计结果中col不同值相加的平均值<br>举例：<br>hive&gt; select avg(t) from lxw_dual;<br>50<br>hive&gt; select avg (distinct t) from lxw_dual;<br>30</p></li><li><p>最小值统计函数: min<br>语法: min(col)<br>返回值: double<br>说明: 统计结果集中col字段的最小值<br>举例：<br>hive&gt; select min(t) from lxw_dual;<br>20</p></li><li><p>最大值统计函数: max<br>语法: maxcol)<br>返回值: double<br>说明: 统计结果集中col字段的最大值<br>举例：<br>hive&gt; select max(t) from lxw_dual;<br>120</p></li><li><p>非空集合总体变量函数: var_pop<br>语法: var_pop(col)<br>返回值: double<br>说明: 统计结果集中col非空集合的总体变量（忽略null）<br>举例：</p></li><li><p>非空集合样本变量函数: var_samp<br>语法: var_samp (col)<br>返回值: double<br>说明: 统计结果集中col非空集合的样本变量（忽略null）<br>举例：</p></li><li><p>总体标准偏离函数: stddev_pop<br>语法: stddev_pop(col)<br>返回值: double<br>说明: 该函数计算总体标准偏离，并返回总体变量的平方根，其返回值与VAR_POP函数的平方根相同<br>举例：</p></li><li><p>样本标准偏离函数: stddev_samp<br>语法: stddev_samp (col)<br>返回值: double<br>说明: 该函数计算样本标准偏离<br>举例：</p></li></ol><p>10．中位数函数: percentile<br>语法: percentile(BIGINT col, p)<br>返回值: double<br>说明: 求准确的第pth个百分位数，p必须介于0和1之间，但是col字段目前只支持整数，不支持浮点数类型<br>举例：</p><ol start="11"><li><p>中位数函数: percentile<br>语法: percentile(BIGINT col, array(p1 [, p2]…))<br>返回值: array<double><br>说明: 功能和上述类似，之后后面可以输入多个百分位数，返回类型也为array<double>，其中为对应的百分位数。<br>举例：<br>select percentile(score,&lt;0.2,0.4&gt;) from lxw_dual； 取0.2，0.4位置的数据</double></double></p></li><li><p>近似中位数函数: percentile_approx<br>语法: percentile_approx(DOUBLE col, p [, B])<br>返回值: double<br>说明: 求近似的第pth个百分位数，p必须介于0和1之间，返回类型为double，但是col字段支持浮点类型。参数B控制内存消耗的近似精度，B越大，结果的准确度越高。默认为10,000。当col字段中的distinct值的个数小于B时，结果为准确的百分位数<br>举例：</p></li><li><p>近似中位数函数: percentile_approx<br>语法: percentile_approx(DOUBLE col, array(p1 [, p2]…) [, B])<br>返回值: array<double><br>说明: 功能和上述类似，之后后面可以输入多个百分位数，返回类型也为array<double>，其中为对应的百分位数。<br>举例：</double></double></p></li><li><p>直方图: histogram_numeric<br>语法: histogram_numeric(col, b)<br>返回值: array&lt;struct {‘x’,‘y’}&gt;<br>说明: 以b为基准计算col的直方图信息。<br>举例：<br>hive&gt; select histogram_numeric(100,5) from lxw_dual;<br>[{“x”:100.0,”y”:1.0}]</p></li></ol><p>九、复合类型构建操作</p><ol><li><p>Map类型构建: map<br>语法: map (key1, value1, key2, value2, …)<br>说明：根据输入的key和value对构建map类型<br>举例：<br>hive&gt; Create table lxw_test as select map(‘100’,’tom’,’200’,’mary’) as t from lxw_dual;<br>hive&gt; describe lxw_test;<br>t       map&lt;string,string&gt;<br>hive&gt; select t from lxw_test;<br>{“100”:”tom”,”200”:”mary”}</p></li><li><p>Struct类型构建: struct<br>语法: struct(val1, val2, val3, …)<br>说明：根据输入的参数构建结构体struct类型<br>举例：<br>hive&gt; create table lxw_test as select struct(‘tom’,’mary’,’tim’) as t from lxw_dual;<br>hive&gt; describe lxw_test;<br>t       struct<a href="col1:string,col2:string,col3:string" target="_blank" rel="noopener">col1:string,col2:string,col3:string</a><br>hive&gt; select t from lxw_test;<br>{“col1”:”tom”,”col2”:”mary”,”col3”:”tim”}</p></li><li><p>array类型构建: array<br>语法: array(val1, val2, …)<br>说明：根据输入的参数构建数组array类型<br>举例：<br>hive&gt; create table lxw_test as select array(“tom”,”mary”,”tim”) as t from lxw_dual;<br>hive&gt; describe lxw_test;<br>t       array<string><br>hive&gt; select t from lxw_test;<br>[“tom”,”mary”,”tim”]</string></p></li></ol><p>十、复杂类型访问操作</p><ol><li><p>array类型访问: A[n]<br>语法: A[n]<br>操作类型: A为array类型，n为int类型<br>说明：返回数组A中的第n个变量值。数组的起始下标为0。比如，A是个值为[‘foo’, ‘bar’]的数组类型，那么A[0]将返回’foo’,而A[1]将返回’bar’<br>举例：<br>hive&gt; create table lxw_test as select array(“tom”,”mary”,”tim”) as t from lxw_dual;<br>hive&gt; select t[0],t[1],t[2] from lxw_test;<br>tom     mary    tim</p></li><li><p>map类型访问: M[key]<br>语法: M[key]<br>操作类型: M为map类型，key为map中的key值<br>说明：返回map类型M中，key值为指定值的value值。比如，M是值为{‘f’ -&gt; ‘foo’, ‘b’ -&gt; ‘bar’, ‘all’ -&gt; ‘foobar’}的map类型，那么M[‘all’]将会返回’foobar’<br>举例：<br>hive&gt; Create table lxw_test as select map(‘100’,’tom’,’200’,’mary’) as t from lxw_dual;<br>hive&gt; select t[‘200’],t[‘100’] from lxw_test;<br>mary    tom</p></li><li><p>struct类型访问: S.x<br>语法: S.x<br>操作类型: S为struct类型<br>说明：返回结构体S中的x字段。比如，对于结构体struct foobar {int foo, int bar}，foobar.foo返回结构体中的foo字段<br>举例：<br>hive&gt; create table lxw_test as select struct(‘tom’,’mary’,’tim’) as t from lxw_dual;<br>hive&gt; describe lxw_test;<br>t       struct<a href="col1:string,col2:string,col3:string" target="_blank" rel="noopener">col1:string,col2:string,col3:string</a><br>hive&gt; select t.col1,t.col3 from lxw_test;<br>tom     tim</p></li></ol><p>十一、复杂类型长度统计函数</p><ol><li><p>Map类型长度函数: size(Map&lt;K.V&gt;)<br>语法: size(Map&lt;K.V&gt;)<br>返回值: int<br>说明: 返回map类型的长度<br>举例：<br>hive&gt; select size(map(‘100’,’tom’,’101’,’mary’)) from lxw_dual;<br>2</p></li><li><p>array类型长度函数: size(Array<t>)<br>语法: size(Array<t>)<br>返回值: int<br>说明: 返回array类型的长度<br>举例：<br>hive&gt; select size(array(‘100’,’101’,’102’,’103’)) from lxw_dual;<br>4</t></t></p></li><li><p>类型转换函数<br>类型转换函数: cast<br>语法: cast(expr as <type>)<br>返回值: Expected “=” to follow “type”<br>说明: 返回array类型的长度<br>举例：<br>hive&gt; select cast(1 as bigint) from lxw_dual;<br>1</type></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据科学速查手册</title>
      <link href="/2021/06/19/data-sciecnt-menu/"/>
      <url>/2021/06/19/data-sciecnt-menu/</url>
      
        <content type="html"><![CDATA[<h3 id="Python基础入门"><a href="#Python基础入门" class="headerlink" title="Python基础入门"></a>Python基础入门</h3><p><img src="beginner.jpg" alt="Python基础入门"></p><h3 id="Python进阶知识"><a href="#Python进阶知识" class="headerlink" title="Python进阶知识"></a>Python进阶知识</h3><p><img src="cheet1.jpg" alt="Python进阶知识"><br><img src="cheet2.jpg" alt="Python进阶知识"></p><h3 id="jupyter基础操作"><a href="#jupyter基础操作" class="headerlink" title="jupyter基础操作"></a>jupyter基础操作</h3><p><img src="jupyter.jpg" alt="jupyter基础操作"></p><h3 id="Pandas基础知识"><a href="#Pandas基础知识" class="headerlink" title="Pandas基础知识"></a>Pandas基础知识</h3><p><img src="pandas.jpg" alt="Pandas基础知识"></p><h3 id="Numpy基础知识"><a href="#Numpy基础知识" class="headerlink" title="Numpy基础知识"></a>Numpy基础知识</h3><p><img src="numpy.jpg" alt="Numpy基础知识"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL笔试经典50题及答案解析</title>
      <link href="/2021/06/19/sql-basic-question-and-answer/"/>
      <url>/2021/06/19/sql-basic-question-and-answer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Excel处理数据的级别是万条以内，当超过10万条以上时在exce里操作是极其困难的，这时候就需要我们使用SQL来查询，俗称取数。对于SQl的学习建议在了解基本逻辑后立刻进入项目练习，以下是来源于网络的sql练习题目及答案解析</p></blockquote><p>1.SQL执行顺序<br><img src="sql-run-oder.png" alt="SQL执行顺序"></p><p>2、建表语句</p><pre><code>create table Student(sid varchar(10),sname varchar(10),sage datetime,ssex nvarchar(10));insert into Student values(&#39;01&#39; , &#39;赵雷&#39; , &#39;1990-01-01&#39; , &#39;男&#39;);insert into Student values(&#39;02&#39; , &#39;钱电&#39; , &#39;1990-12-21&#39; , &#39;男&#39;);insert into Student values(&#39;03&#39; , &#39;孙风&#39; , &#39;1990-05-20&#39; , &#39;男&#39;);insert into Student values(&#39;04&#39; , &#39;李云&#39; , &#39;1990-08-06&#39; , &#39;男&#39;);insert into Student values(&#39;05&#39; , &#39;周梅&#39; , &#39;1991-12-01&#39; , &#39;女&#39;);insert into Student values(&#39;06&#39; , &#39;吴兰&#39; , &#39;1992-03-01&#39; , &#39;女&#39;);insert into Student values(&#39;07&#39; , &#39;郑竹&#39; , &#39;1989-07-01&#39; , &#39;女&#39;);insert into Student values(&#39;08&#39; , &#39;王菊&#39; , &#39;1990-01-20&#39; , &#39;女&#39;);create table Course(cid varchar(10),cname varchar(10),tid varchar(10));insert into Course values(&#39;01&#39; , &#39;语文&#39; , &#39;02&#39;);insert into Course values(&#39;02&#39; , &#39;数学&#39; , &#39;01&#39;);insert into Course values(&#39;03&#39; , &#39;英语&#39; , &#39;03&#39;);create table Teacher(tid varchar(10),tname varchar(10));insert into Teacher values(&#39;01&#39; , &#39;张三&#39;);insert into Teacher values(&#39;02&#39; , &#39;李四&#39;);insert into Teacher values(&#39;03&#39; , &#39;王五&#39;);create table SC(sid varchar(10),cid varchar(10),score decimal(18,1));insert into SC values(&#39;01&#39; , &#39;01&#39; , 80);insert into SC values(&#39;01&#39; , &#39;02&#39; , 90);insert into SC values(&#39;01&#39; , &#39;03&#39; , 99);insert into SC values(&#39;02&#39; , &#39;01&#39; , 70);insert into SC values(&#39;02&#39; , &#39;02&#39; , 60);insert into SC values(&#39;02&#39; , &#39;03&#39; , 80);insert into SC values(&#39;03&#39; , &#39;01&#39; , 80);insert into SC values(&#39;03&#39; , &#39;02&#39; , 80);insert into SC values(&#39;03&#39; , &#39;03&#39; , 80);insert into SC values(&#39;04&#39; , &#39;01&#39; , 50);insert into SC values(&#39;04&#39; , &#39;02&#39; , 30);insert into SC values(&#39;04&#39; , &#39;03&#39; , 20);insert into SC values(&#39;05&#39; , &#39;01&#39; , 76);insert into SC values(&#39;05&#39; , &#39;02&#39; , 87);insert into SC values(&#39;06&#39; , &#39;01&#39; , 31);insert into SC values(&#39;06&#39; , &#39;03&#39; , 34);insert into SC values(&#39;07&#39; , &#39;02&#39; , 89);insert into SC values(&#39;07&#39; , &#39;03&#39; , 98);</code></pre><p>3、表结构预览</p><pre><code>–学生表Student(SId,Sname,Sage,Ssex)–SId 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别–课程表Course(CId,Cname,TId)–CId 课程编号,Cname 课程名称,TId 教师编号–教师表Teacher(TId,Tname)–TId 教师编号,Tname 教师姓名–成绩表SC(SId,CId,score)–SId 学生编号,CId 课程编号,score 分数</code></pre><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>1、查询“01”课程比“02”课程成绩高的所有学生的学号；<br>2、查询平均成绩大于60分的同学的学号和平均成绩；<br>3、查询所有同学的学号、姓名、选课数、总成绩<br>4、查询姓“李”的老师的个数；<br>5、查询没学过“张三”老师课的同学的学号、姓名；<br>6、查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名；<br>7、查询学过“张三”老师所教的课的同学的学号、姓名；<br>8、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；<br>9、查询所有课程成绩小于60分的同学的学号、姓名；<br>10、查询没有学全所有课的同学的学号、姓名；<br>11、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；<br>12、查询和”01″号的同学学习的课程完全相同的其他同学的学号和姓名<br>13、把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；<br>14、查询没学过”张三”老师讲授的任一门课程的学生姓名<br>15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩<br>16、检索”01″课程分数小于60，按分数降序排列的学生信息<br>17、按平均成绩从高到低显示所有学生的平均成绩<br>18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率<br>19、按各科平均成绩从低到高和及格率的百分数从高到低顺序<br>20、查询学生的总成绩并进行排名<br>21、查询不同老师所教不同课程平均分从高到低显示<br>22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩<br>23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比<br>24、查询学生平均成绩及其名次<br>25、查询各科成绩前三名的记录<br>26、查询每门课程被选修的学生数<br>27、查询出只选修了一门课程的全部学生的学号和姓名<br>28、查询男生、女生人数<br>29、查询名字中含有”风”字的学生信息<br>30、查询同名同性学生名单，并统计同名人数<br>31、查询1990年出生的学生名单(注：Student表中Sage列的类型是datetime)<br>32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列<br>37、查询不及格的课程，并按课程号从大到小排列<br>38、查询课程编号为”01″且课程成绩在60分以上的学生的学号和姓名；<br>40、查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩<br>42、查询每门功课成绩最好的前两名<br>43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列<br>44、检索至少选修两门课程的学生学号<br>45、查询选修了全部课程的学生信息<br>46、查询各学生的年龄<br>47、查询本周过生日的学生<br>48、查询下周过生日的学生<br>49、查询本月过生日的学生<br>50、查询下月过生日的学生</p><br><br><br><br><br><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><pre><code>1、查询“01”课程比“02”课程成绩高的所有学生的学号；select distinct t1.sid as sidfrom     (select * from sc where cid=&#39;01&#39;)t1left join     (select * from sc where cid=&#39;02&#39;)t2on t1.sid=t2.sidwhere t1.score&gt;t2.score2、查询平均成绩大于60分的同学的学号和平均成绩；select     sid    ,avg(score)from scgroup by sidhaving avg(score)&gt;603、查询所有同学的学号、姓名、选课数、总成绩select    student.sid as sid    ,sname    ,count(distinct cid) course_cnt    ,sum(score) as total_scorefrom studentleft join sc on student.sid=sc.sidgroup by sid,sname4、查询姓“李”的老师的个数；select    count(distinct tid) as teacher_cntfrom teacherwhere tname like &#39;李%&#39;5、查询没学过“张三”老师课的同学的学号、姓名；select    sid,snamefrom studentwhere sid not in     (        select            sc.sid        from teacher        left join course            on teacher.tid=course.tid        left join sc            on course.cid=sc.cid        where teacher.tname=&#39;张三&#39;    )6、查询学过“01”并且也学过编号“02”课程的同学的学号、姓名；select    t.sid as sid    ,snamefrom     (        select            sid            ,count(if(cid=&#39;01&#39;,score,null)) as count1            ,count(if(cid=&#39;02&#39;,score,null)) as count2        from sc        group by sid        having count(if(cid=&#39;01&#39;,score,null))&gt;0 and count(if(cid=&#39;02&#39;,score,null))&gt;0    )tleft join student    on t.sid=student.sid7、查询学过“张三”老师所教的课的同学的学号、姓名；select    student.sid    ,snamefrom     (        select            distinct cid         from course        left join teacher         on course.tid=teacher.tid        where teacher.tname=&#39;张三&#39;    )courseleft join sc     on course.cid=sc.cidleft join student    on sc.sid=student.sidgroup by student.sid,sname8、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；select    t1.sid,snamefrom     (        select distinct t1.sid as sid        from             (select * from sc where cid=&#39;01&#39;)t1        left join             (select * from sc where cid=&#39;02&#39;)t2        on t1.sid=t2.sid        where t1.score&gt;t2.score    )t1left join student    on t1.sid=student.sid9、查询所有课程成绩小于60分的同学的学号、姓名；select    t1.sid,snamefrom     (        select            sid,max(score)        from sc        group by sid        having max(score&lt;60)    )t1left join student    on t1.sid=student.sid10、查询没有学全所有课的同学的学号、姓名；select    t1.sid,snamefrom     (        select            count(cid),sid        from sc        group by sid        having count(cid) &lt; (select count(distinct cid) from course)    )t1left join student    on t1.sid=student.sid11、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；select    distinct sc.sidfrom     (        select            cid        from sc        where sid=&#39;01&#39;    )t1left join sc    on t1.cid=sc.cid12、查询和”01″号的同学学习的课程完全相同的其他同学的学号和姓名#注意是和&#39;01&#39;号同学课程完全相同但非学习课程数相同的,这里我用左连接解决这个问题select    t1.sid,snamefrom    (        select            sc.sid            ,count(distinct sc.cid)        from             (                select                    cid                from sc                where sid=&#39;01&#39;            )t1 #选出01的同学所学的课程        left join sc            on t1.cid=sc.cid        group by sc.sid        having count(distinct sc.cid)= (select count(distinct cid) from sc where sid = &#39;01&#39;)    )t1left join student    on t1.sid=student.sidwhere t1.sid!=&#39;01&#39;13、把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；#暂跳过update题目14、查询没学过”张三”老师讲授的任一门课程的学生姓名select     snamefrom studentwhere sid not in    (        select            distinct sid        from sc        left join course            on sc.cid=course.cid        left join teacher            on course.tid=teacher.tid         where tname=&#39;张三&#39;    )15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩select    t1.sid,sname,avg_scorefrom     (        select            sid,count(if(score&lt;60,cid,null)),avg(score) as avg_score        from sc        group by sid        having count(if(score&lt;60,cid,null)) &gt;=2    )t1left join student    on t1.sid=student.sid16、检索”01″课程分数小于60，按分数降序排列的学生信息select     sid,if(cid=&#39;01&#39;,score,100)from scwhere if(cid=&#39;01&#39;,score,100)&lt;60order by if(cid=&#39;01&#39;,score,100) desc17、按平均成绩从高到低显示所有学生的平均成绩select sid,avg(score)from scgroup by sidorder by avg(score) desc18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率select    sc.cid    ,cname    ,max(score) as max_score    ,min(score) as min_score    ,avg(score) as avg_score    ,count(if(score&gt;=60,sid,null))/count(sid) as pass_ratefrom sc left join course    on sc.cid=course.cidgroup by sc.cid19、按各科平均成绩从低到高和及格率的百分数从高到低顺序#这里先按照平均成绩排序，再按照及格百分数排序，题目有点奇怪select     cid    ,avg(score) as avg_score    ,count(if(score&gt;=60,sid,null))/count(sid) as pass_ratefrom scgroup by cidorder by avg_score,pass_rate desc20、查询学生的总成绩并进行排名select    sid    ,sum(score) as sum_scorefrom scgroup by sidorder by sum_score desc21、查询不同老师所教不同课程平均分从高到低显示select    tid    ,avg(score) as avg_scorefrom courseleft join sc    on course.cid=sc.cidgroup by tidorder by avg_score desc22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩select    sid,rank_num,score,cidfrom    (        select            rank() over(partition by cid order by score desc) as rank_num            ,sid            ,score            ,cid        from sc    )twhere rank_num in (2,3)23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比select    sc.cid    ,cname    ,count(if(score between 85 and 100,sid,null))/count(sid)    ,count(if(score between 70 and 85,sid,null))/count(sid)    ,count(if(score between 60 and 70,sid,null))/count(sid)    ,count(if(score between 0 and 60,sid,null))/count(sid)from scleft join course    on sc.cid=course.cidgroup by sc.cid,cname24、查询学生平均成绩及其名次select    sid    ,avg_score    ,rank() over (order by avg_score desc)from     (        select            sid            ,avg(score) as avg_score        from sc        group by sid    )t25、查询各科成绩前三名的记录select    sid,cid,rank1from     (        select            cid            ,sid            ,rank() over(partition by cid order by score desc) as rank1        from sc    )twhere rank1&lt;=326、查询每门课程被选修的学生数select    count(sid)    ,cidfrom scgroup by cid27、查询出只选修了一门课程的全部学生的学号和姓名#只查出来sid即可，后面懒得交student表select    sidfrom scgroup by sidhaving count(cid) =128、查询男生、女生人数select    ssex    ,count(distinct sid)from studentgroup by ssex29、查询名字中含有”风”字的学生信息select    sid,snamefrom studentwhere sname like &#39;%风%&#39;30、查询同名同性学生名单，并统计同名人数#题目有歧义，这套题的质量感觉有点差select    ssex    ,sname    ,count(sid)from studentgroup by ssex,snamehaving count(sid)&gt;=231、查询1990年出生的学生名单(注：Student表中Sage列的类型是datetime)select    sid,sname,sagefrom studentwhere year(sage)=199032、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列select    cid,avg(score) as avg_scorefrom scgroup by cidorder by avg_score,cid desc37、查询不及格的课程，并按课程号从大到小排列#有问题的题目select    cid,sid,scorefrom scwhere score&lt;60order by cid desc,sid38、查询课程编号为”01″且课程成绩在60分以上的学生的学号和姓名；select    sid,cid,scorefrom scwhere cid=&#39;01&#39; and score&gt;6040、查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩select    sc.sid,sname,cname,scorefrom scleft join course    on sc.cid=course.cidleft join teacher    on course.tid=teacher.tidleft join student    on sc.sid=student.sidwhere tname=&#39;张三&#39;order by score desclimit 1;42、查询每门功课成绩最好的前两名##感觉题目重复了select    cid,sid,rank1from     (        select            cid            ,sid            ,rank() over(partition by cid order by score desc) as rank1        from sc     )twhere rank1 &lt;=243、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列select    cid    ,count(sid) as cntfrom scgroup by cidhaving cnt&gt;=5order by count(sid) desc,cid44、检索至少选修两门课程的学生学号select    sid    ,count(cid)from scgroup by sidhaving count(cid)&gt;=245、查询选修了全部课程的学生信息#不太严谨，但实务中应该没问题，如需严谨见12题思路select    sid    ,count(cid)from scgroup by sidhaving count(cid)=(select count(distinct cid) from sc)46、查询各学生的年龄select    sid,sname,year(curdate())-year(sage) as sagefrom student47、查询本周过生日的学生select    sid,sname,sagefrom studentwhere weekofyear(sage)=weekofyear(curdate())48、查询下周过生日的学生select     sid,sname,sagefrom studentwhere weekofyear(sage) = weekofyear(date_add(curdate(),interval 1 week))49、查询本月过生日的学生select    sid,sname,sagefrom studentwhere month(sage) = month(curdate())50、查询下月过生日的学生select    sid,sname,sagefrom studentwhere month(date_sub(sage,interval 1 month)) = month(curdate())</code></pre><p>题目及答案来源：(<a href="https://zhuanlan.zhihu.com/p/53302593" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53302593</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理学研究方法笔记</title>
      <link href="/2021/06/19/psychological-method/"/>
      <url>/2021/06/19/psychological-method/</url>
      
        <content type="html"><![CDATA[<h3 id="一、科学与常识"><a href="#一、科学与常识" class="headerlink" title="一、科学与常识"></a>一、科学与常识</h3><blockquote><p>常识主要指在经验基础上形成的对客观世界的认识；<br>科学则是在系统观察基础上形成的对客观世界的认识。</p></blockquote><p>1、相似点</p><p>常识被定义为：在人们的实践基础上产生的概念以及对事物的一般性认识，</p><p>科学则是对常识的系统化和对常识的在控制基础上的验证、修正和发展。</p><p>2、不同点</p><p>对概念的理解与使用不同；</p><p>对概念和理论的系统化方法不同；</p><p>控制是科学研究的特点，但常识无需控制；</p><p>如果常识和科学相背离，不要轻易否定任何一方。</p><p>Q：</p><p>你如何看待尚未经过科学检验的常识？</p><p>科学和常识相背离时，你该怎么办？</p><p>科学有能力检验的存在有多少？</p><h3 id="二、知识的主要来源"><a href="#二、知识的主要来源" class="headerlink" title="二、知识的主要来源"></a>二、知识的主要来源</h3><p>1、固执：坚信你所认为的就是真实，固执使你获取的信息成为你知识体系的一部分（也许与经验有关）；</p><p>2、权威：如果某个权威认为是对的，就是对的；如果大家都认为是那样，就是那样；</p><p>3、直觉：只是相信，无需经验证明（虽然也许与经验有关）；</p><p>4、常识：经验告诉你的；</p><p>5、科学：探索客观实在的一种方法。</p><p>Q：</p><p>在你的知识结构中大约有多少是经过科学方法探索得到的？</p><p>经过科学验证和未经过科学验证的区别是什么？</p><p>科学证明的意义？</p><h3 id="三、科学及科学目标"><a href="#三、科学及科学目标" class="headerlink" title="三、科学及科学目标"></a>三、科学及科学目标</h3><p>1、什么是科学</p><p>达尔文：科学就是整理事实，从中发现规律，做出结论。</p><p>《辞海》（1999）：科学：运用范畴、定理、定律等思维形式反映现实世界各种现象的本质和规律的知识体系。</p><p>2、科学研究方法</p><p>科学研究方法是探索世界的一种方法。通过这样的方法得出的结论反映的应是客观事实本身，而不受人们的主观看法影响。不同的研究者使用这样的方法在针对同一问题和相同对象时所得出的结论应当是一致的。</p><p>科学研究方法的基本假设是：世界的真实特性完全独立于人们对它们的主观认识。</p><p>3、科学研究</p><p>科学研究是对假设的有关自然现象中关系的系统的、有所控制的和实证的调查和检验。</p><p> 科学研究是系统和有所控制的；</p><p> 科学调查采用实证方法；</p><p> 主观看法必须经过客观检验。</p><p>4、科学检验基本原则</p><p>科学研究中所采用的检验方法遵循客观性原则，即，尽可能独立于研究者的个人信念、直觉、偏见、态度和情绪等。</p><p>5、目标</p><p>科学的基本目标是探索和解释自然现象，对自然现象的系统性解释即称为理论。这样，探索和解释又成为科学研究的两个阶段目标。在这两个阶段目标之下，有四个具体目的：描述、预测、解释和控制。</p><h3 id="五、科学理论"><a href="#五、科学理论" class="headerlink" title="五、科学理论"></a>五、科学理论</h3><p>1、理论</p><p>一个理论是一组概念之间的相互关系，这些概念代表对于某种现象的系统看法和观点。这些看法和观点通常用一些具体的变量及其相互关系来表达，用以解释和预测现象。</p><p>2、理论含义</p><p>一个理论由一组相关概念组成；</p><p>一个理论表示变量间的相互关系，也代表着由变量所描述的对于现象的系统看法；</p><p>一个理论解释某种现象。理论对于现象的解释通过具体化哪些变量与哪些变量相关，以及如何相关来实现。</p><h2 id="六、科学探索"><a href="#六、科学探索" class="headerlink" title="六、科学探索"></a>六、科学探索</h2><p>1、一般过程</p><p>演绎: 问题和假设源于理论；</p><p>实验观察：对问题进行实验检验；</p><p>证明：搜集数据，以证明理论；</p><p>实验推论：将某一研究结果推论到更大的范围；</p><p>归纳: 从研究结果中产生相关理论。</p><p>2、理论与研究之间的关系</p><p>理论        研究（演绎模型）</p><p>（理论引导研究）</p><p>研究        理论（归纳模型）</p><p>（通过观察提出要研究的问题，产生假设，并提供数</p><p>据使已有的理论更加完善，或者发展出新的理论）</p><h3 id="七、科学思维的特征"><a href="#七、科学思维的特征" class="headerlink" title="七、科学思维的特征"></a>七、科学思维的特征</h3><p>决定论：任何事件都有其原因，所有人类行为背后都有其原因。</p><p>可揭示性：使用科学方法能够揭示事件的原因；人类行为的规律可以用科学方法来揭示。</p><p>客观性：研究结果不受研究者影响。</p><p>数据支持：研究结论需要有数据支持。</p>]]></content>
      
      
      <categories>
          
          <category> 心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考试、读书、学习是一回事？</title>
      <link href="/2021/06/19/are-read-book-and-learning-is-same-thing/"/>
      <url>/2021/06/19/are-read-book-and-learning-is-same-thing/</url>
      
        <content type="html"><![CDATA[<p>读书、学习在任何时代都是提高、进步的一条可行的渠道。如果我们不会学习、不知道如何选择，试问我们这辈子是不是有可能混吃等死呢？中国从古代到现代的选拔人才的方式越来越丰富，从开始的推举制度到后来的科举制度，从最开始只是世仕家大族到后来平民也有机会，这就是一个好的发展趋势。放到我们现在来说，高考、考研就是改变人，生轨迹的重要战役。</p><p>但是从大学毕业以后呢，考试、读书、学习就不是一回事了，或者说从一开始这就是三件事。家里人不了解，以为只要继续读，继续上就行。在家里的人眼里，以为读书 = 学习 = 考试，这条等式至少在我大学前，我也是这么认为的。</p><p>对于考试的态度，我是在大学时代发生转变的。当时我立下一个规矩，不再将考试成绩作为自己的评价标准，转而开始学习其他领域的知识，尽量拓展自己的知识领域，投向计算机学习的怀抱，当时的想法是我想去了解这个东西，但是我就是不知道这个东西是个啥，也无从下手，更不知道如何学，不管，多试试就知道了。到了现在，自己对于这三件事情有了一点自己的浅见：</p><p>读书，就是简单的读书呗。读书体系总体来说可以分为几层，经典且有影响力的论文、经典教材、牛人写的文章以及网络上其他文章，按照这个分级来选择读物，你会发现自己喜欢的层次是出在哪里。当然，这里并无好坏之分，你喜欢就好。书籍不重要，重要的是背后的写书的人。人只要找对了，书一般不会差。只看书名就以为能解决问题，还是太天真了。</p><p>学习是一个更大的范畴，贯穿一个人的一生。只不过学习这件事，不需要挂在嘴上，也不需要去炫耀，自己默默搞就是了，知识付费的打卡展示、每天告诉别人自己又学习了、今天我复习了10多个小时，这种事情不必说的。直接关闭朋友圈最直接解决这个问题。学习是基于经验，行为发生持久的变化，从开始学习走路、奔跑，到后来学习识字、写文章，还有社会生存技能等，这些都是学习的结果。可是，我们并没有在学会了向全天下人说吧。尽力的炫耀更你的能力可能成反比。知耻近乎勇，以前不明白这句话，忽然发现，一个人知道自己的局限，并且承认自己不知道是有多难，尤其是有些身份地位的，承认这种局限就更难了。在过往的时间里，我也曾有过这样的心态，遇到点小事就发朋友圈，求别人点赞，或让别人关注自己。大学里最爱做的就是这个事情，那时候也正好是社交软件发展的黄金时期。</p><p>不过反观一想，多没意思呀，自己默默做就是了，能做到什么程度，自己心中有数即可。</p><p>当学习仅仅是为了考试的时候，思维会被局限在只去关注重点知识，这在短期来说可以接受的，考试就是要功利学习。例如考研，从大的范围来说就是就是个考试，毕竟这是一道门槛，没有考试，我们怎么知道你的水平，统一标准还是要有的。曾经有个有趣的段子，说山东考生高分低能，除了会考试什么也不会。这里就有问题了。考生是因为只会考试，还是只能考试，你给我找一个除了考试之外还比较不错的晋升途径吗？多半是没有的，既然没有那就继续考呗。这也许是读书 = 学习 = 考试的来源了。</p><p>学习在任何时代都是进步的渠道，我们想要提高自己的，绝对不能放松。但是注意，学习不等于报班，互联网的发达程度已经到了自己可以学习的地步了。勤思考、多动脑、别偷懒，自己去多查资料，还怕学不会？</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础与组成原理图解（框架）</title>
      <link href="/2021/06/19/compter-basic-and-principle-of-computer/"/>
      <url>/2021/06/19/compter-basic-and-principle-of-computer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>尽管会写一点代码，但是一开始对计算机体系是一无所知的。针对计算机需要了解的内容，每天学习点基础知识，把以前欠下的课都补上。<br>以下是计算机组成原理框架图和需要了解的硬件知识：</p></blockquote><p><img src="prinpleofcompter.png" alt="计算机组成原理"></p><blockquote><p>程序员需要了解的计算机知识：<br>主要包括CPU、内存、磁盘，可下载pdf查看<br><a href="computer-basic.pdf">计算机基础pdf</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理补偿机制下的人们是怎么生活的？</title>
      <link href="/2021/06/19/psychological-compensation/"/>
      <url>/2021/06/19/psychological-compensation/</url>
      
        <content type="html"><![CDATA[<p><img src="11.jpg" alt></p><blockquote><p>在心理学上，当由于主客观条件的限制和阻碍使个人的目标无法实现时，设法以新的目标代替原有目标，以现在的成功体验去弥补原有失败的痛苦，这种心理被称为“补偿心理“。</p></blockquote><p>简单地说，用成功代替失败，让自己情绪及认知合理化，以保持内心不焦虑。</p><p>这种心理补偿在我们生活中很常见，例如，用不断买书来代替自己读不了书的尴尬；多吃才有力气减肥；最近心情不好，所以多买点衣服；今天努力了，所以晚上先休息2小时以犒劳自己等，这些都是有心理补偿的影子，回想下自己是否也有这种的想法或者行为，是不是每天都经历这样的事情呢？从补偿的角度来看，问题也不太大，可是一直沉溺不知反思，不认清现实却是可怕的。</p><p>想一想自己每天活在一个虚假的世界里，然后突然被拉回到现实中，这种两者间的差距会不会有一种撕裂感，不知道你是否喜欢看言情、玄幻文学，我以前也看过，当时看得挺舒服，幻想自己是小说里的大侠，武功盖世、身边美女如云，但是早上起床后照着镜子里的自己，发现自己太天真了，这是学生时代的真实写照。你呢，是不是也这么傻过。言情、玄幻文学作品的兴起，解决了许多人的现实问题，为什么那么多人喜欢看，就是这种现实中的挫败碰上了现实，两者一碰撞，选择逃避到一个安乐窝里，自己在里面爽翻天也没有打扰，岂不快哉，你愿意过这样的生活吗？</p><p>补偿心理在消费上也有所体现。补偿性消费的本质特征是通过消费行为来弥补某些心理缺失或威胁, 强调的是消费行为作为满足需求的一种替代性手段和工具, 而非功能性价值。自由感的缺失常常使人感觉对周围的环境没有控制感, 不能随心所欲做自己喜欢的事情。在 这种情况下, 人们在消费行为上也可能表现出补偿性动机 就像《西虹市首富》里的沈腾，在现实中如果真的有这样的事情发生，且没有限制因素的话，你会怎么做？大手大脚花钱，处处显摆，生怕别人不知道还是谨小慎微不显山露水？也许我们没有那样的机会，但是可能会用别的方式来替代。比如说每次心情不好就会多吃，吃完后特别开心，心情压抑也就减少了，于是减肥就成为一句空话了。</p><p>生而要自强。自强自立不是白说的。补偿心理的作祟在一定程度上是因为我们不够自强，自强的标准自我勉励，建立行为标准，“抑心而自强”，克制无端的欲望，增强自我勉励的能力。补偿心理对于学习者来说，意味着三天打鱼两天晒网。真正的学习者，是没有时间炫耀的。不要用我今天打卡了，来代替你掌握知识，这是两个事情，你可以不外显自己的学习进度，但是一定要搞明白自己在做什么，目的是什么。</p><p>对于自己学到内容来说，可以说凡是我能学到的，我都不屑一顾。然后继续下一个难题的突破。</p>]]></content>
      
      
      <categories>
          
          <category> 心理学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理补偿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何对学习进行系统化的思考？</title>
      <link href="/2021/06/19/how-to-think/"/>
      <url>/2021/06/19/how-to-think/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2021年考研已经开始报名，你是否真想考上还是想游历一番？本篇文章将对学习进行较为系统化的梳理，还是以考研为例，希望对你有点帮助。</p></blockquote><p>首先要明确，学习是手段，目的是关键。有的人喜欢学习，可能还在学习的汪洋大海里漫游，而有的人已经在学习的大海找到了彼岸，直接坐着快艇前往，两者的对学习的水平认知高下立判。上篇文章中简单说了一个技巧，这次我想把我之前遇到的，想到的梳理一遍，也好帮助后来人。</p><p>其实可以把学习比做打仗，从更大的维度上思考如何打赢一场仗。对于考试类的学习，相对比较容易了。考试范围已定，答案都是死知识，想要战胜它，不是难事。</p><p>打赢一场仗，从思想建设、计划执行、反馈调整三个方面展开</p><h3 id="第一，思想建设"><a href="#第一，思想建设" class="headerlink" title="第一，思想建设"></a>第一，思想建设</h3><p>对于考研这种事情，一定要坚信自己能考上，但凡在考试前犹豫不决，感觉自己考不上，多半很难考好。你相信自己，不就是一个考试嘛，考不上你顶多付出点时间和金钱，不至于说有多么严重的后果，所以要先相信自己。这不是嘴上说说，而是有自己的实力，自己相信自己的这些准备能帮助自己考上，而不是简单地喊口号。</p><p>思想建设首先是从认知上改变自己对考研或者学习的态度，自己不是为了考而考，学而学，而是为了自己的职业规划，人生理想，改变命运，或者是为了多赚点钱等，这些都是可以的。但是在行动前要做好自己的思想准备，这点至关重要。“革命尚未成功”，大家还要努力。也许你不知道现阶段要什么，只是想考考试试，我想说，尽早放弃试试的心态，除非你是为了体验。180块的考研体验卡虽然便宜，但是也不该这么败家，180块还能看3场电影，吃顿火锅，去优衣库买件衣服呢，所以如果决定要考，那就坚定下自己要考的信念。</p><h3 id="第二，计划执行和落地"><a href="#第二，计划执行和落地" class="headerlink" title="第二，计划执行和落地"></a>第二，计划执行和落地</h3><p>只靠思想建设还不够，还要有计划执行和落地。</p><p>在上一篇文章说，我提到过时间+时间记录法，这个启发来自于《奇特的一生》，也是看李笑来《时间的朋友》得来的。这个方法适用面很广，大家不妨试试。记录的目的是为了让自己了解自己的时间消费。毕竟，时间是自己最宝贵的资源，对于我们这些普通人，唯一的资源也就是时间了，所以珍惜好自己的时间，从记录开始。</p><p>计划的执行和落地需要做这么几件事。统计空闲时间，准备好记录本，定好要学习的内容，一周试行，看看效果。</p><p>也许刚开始不适应，或者觉得比较low，你也可以用其他app等工具代替，这些没啥大问题，核心的目的是为了掌握自己时间，知道什么时间干什么。那可能有人问，我就是不知道自己该干什么，那怎么办？对于这种，更简单了。看看别人怎么做，你照着做就是了，去知乎、考研论坛等找找经验，开始做就是了，整天想，不如时间做。做着做着，可能就来感觉了。可以先问自己几个问题，看看是否已经准备妥当：</p><p>为什么考研？考上之后怎么学习和毕业后有怎样的打算？今年报考的这所院校招多少人？往年的考上的人平均分、最高和最低是多少？你打算考多少分，每门科目多少分，每类题型多少分？你平时怎么分配复习时间？还有，你报名了嘛？</p><h3 id="第三，反馈调整"><a href="#第三，反馈调整" class="headerlink" title="第三，反馈调整"></a>第三，反馈调整</h3><p>如果能做到上面的两步，这一步自然而然也就有了。因为你相信自己，又有计划性，自然会根据不同的情况进行调整了。所以说，万事开头难，从思想认知，到计划执行。最开始走的正当，就没跑了。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>做自己能够掌控的事情，对于无法改变的事情，无需太多关注。毕竟，每个人走的路都是不一样的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 如何学习</title>
      <link href="/2021/06/19/how-to-learn/"/>
      <url>/2021/06/19/how-to-learn/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【持续学习不停息】，心理学考研知识一手掌握！</p></blockquote><p>一直以来，学习这个话题都是经久不衰的，不管出于什么样的原因，学习这个事情是没有错的，但关键在于我们要学什么以及我们怎么学。</p><h3 id="学什么"><a href="#学什么" class="headerlink" title="学什么"></a>学什么</h3><p>我们现在学习的内容是否有用呢？这估计是多数人面临的第一个问题。</p><p>学生时代听过太多老师说现在学习的内容没有用，数学老师可能会说，隔壁王大婶没有学数学算得都比你们好，当时觉得还挺对，现在一想觉得有点可笑，我们学的内容不仅仅是停留在表面，而是学会各种学科的背后的逻辑，这种逻辑性是一种高层次的训练，数学公式的推导及对难题的解题背后传达的是我们对问题的逻辑性思考。无论是写文章，写论文，做PPT演讲，逻辑性是最重要的。因此，流于表面工夫的学习是最初级的，到了大学及之后如果还是处于这样的学习阶段，那我们就需要去审视下自己了。</p><p>学什么不仅仅体现在学习背后逻辑性的问题，还体现在自己对问题的思考。问自己一句，我为什么要学？例如考研，为什么你们会来考心理学，为什么选择这个专业、这所学校呢？看了这么久的书，学了这么长的习，有没有想过这些学到的如何去应用呢？这种思考性是第二个对我们有益的。没有思考只是在无意识的学习，很快你便会迷失，即使你考上了，没有这种背后的思考，没有思考后的行动，你依然不知道该如何去做。这也就是考研后综合症（自己起的名字），经历万难后却发现前方的路被灰蒙蒙的雾气所遮盖，为了减少这种情况，建议你多去思考，毕竟，三省吾身，古人诚不欺我也。</p><p>那到底该学点什么呢？问题可以简化一下，问问自己最迫切的学习需求是什么，有哪些是自己的最想知道的，如果没有那可以不用学，如果有，然后可以从体系化的角度看看如何去学习。例如，19年我特别想了解金融学，于是我到知乎找个几篇关于金融学的入门书籍，也询问了自己的同学，那后整理出一份书单，接着就开始看，从曼坤的《经济学原理》，到米什金的《货币紧急学》，罗斯的《公司理财》，博迪的《金融学》，亚当·斯密的《国富论》，一本本拿下，尽管只看了一遍，但是对于我入门了解金融已经足够了，也就是说初级目标达成，如果还想进一步，那就需要在未来多读几遍。</p><h3 id="怎么学？"><a href="#怎么学？" class="headerlink" title="怎么学？"></a>怎么学？</h3><p>上面提到的其实已经包含了怎么学的内容了。无他，就是去找经典的书拿来看看，认真搞一下。这些经典书籍既然能沉淀几十年必有值得读的地方。</p><p>我推荐的学习方式就是找经典，慢慢读，而且不着急。慢就是快，把学到的尽量可以应用上那再好不过了，如果短时间觉得用不上，那就写篇思考类的文章来强化。当初我为了能强化心理学的记忆，选择考研，通过考试来督促自己学习，这种方式我认为是可行的。</p><p>所以多读经典，慢慢读，你会发现自己的阅读能力逐渐就上来了，千万别依赖所谓的捷径就好了，例如摘录几句话，看几个名人名言。在怎么学的过程中，所读的经典是为了看这些人是如何思考的，结论反而是其次，因为我们学习的目的是为了有逻辑的思考，而不是仅仅知道一点信息，你觉得呢？</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
